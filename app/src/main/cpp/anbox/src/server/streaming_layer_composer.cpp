/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include "server/streaming_layer_composer.h"
#include "anbox/graphics/emugl/Renderer.h"
#include "anbox/logger.h"

#include <GLES2/gl2.h>
#include <cstring>

namespace anbox::server {

StreamingLayerComposer::StreamingLayerComposer(
    const std::shared_ptr<::Renderer>& renderer,
    const std::shared_ptr<graphics::Rect>& rect)
    : LayerComposer(renderer, rect, nullptr),  // Pass nullptr for native_window
      renderer_(renderer),
      rect_(rect) {
    INFO("StreamingLayerComposer created for %dx%d", rect_->width(), rect_->height());
    
    // Pre-allocate pixel buffer for frame readback
    pixel_buffer_.resize(rect_->width() * rect_->height() * 4); // RGBA
}

StreamingLayerComposer::~StreamingLayerComposer() {
}

void StreamingLayerComposer::set_frame_callback(FrameCallback callback) {
    frame_callback_ = std::move(callback);
}

void StreamingLayerComposer::submit_layers(const RenderableList& renderables) {
    if (!frame_callback_) {
        // No callback set, nothing to do
        return;
    }
    
    if (!renderer_) {
        WARNING("No renderer available for frame capture");
        return;
    }
    
    uint32_t width = rect_->width();
    uint32_t height = rect_->height();
    
    // Log on first call and periodically
    static int call_count = 0;
    call_count++;
    if (call_count == 1 || (call_count % 100) == 0) {
        INFO("submit_layers called (count=%d) with %zu renderables, display %ux%u",
             call_count, renderables.size(), width, height);
        for (const auto& r : renderables) {
            INFO("  Renderable '%s': buffer=%u, screen_pos=(%d,%d,%d,%d), crop=(%d,%d,%d,%d)",
                 r.name().c_str(), r.buffer(),
                 r.screen_position().left(), r.screen_position().top(),
                 r.screen_position().right(), r.screen_position().bottom(),
                 r.crop().left(), r.crop().top(), r.crop().right(), r.crop().bottom());
        }
    }
    
    // Clear the frame buffer first (black background)
    std::memset(pixel_buffer_.data(), 0, pixel_buffer_.size());
    
    if (renderables.empty()) {
        // No renderables, send black frame
        uint32_t stride = width * 4;
        frame_callback_(pixel_buffer_.data(), width, height, stride);
        return;
    }
    
    // Composite all renderables into the frame buffer
    // Find the topmost renderable that covers the full screen, or composite all
    for (const auto& r : renderables) {
        if (r.buffer() == 0) {
            DEBUG("Skipping renderable '%s': buffer is 0", r.name().c_str());
            continue;
        }
        
        // Get the screen position and crop for this renderable
        auto screen_pos = r.screen_position();
        auto crop = r.crop();
        
        // Get buffer dimensions from crop if available, otherwise use screen position
        int buf_width = crop.width() > 0 ? crop.width() : screen_pos.width();
        int buf_height = crop.height() > 0 ? crop.height() : screen_pos.height();
        
        if (buf_width <= 0 || buf_height <= 0) {
            DEBUG("Skipping renderable '%s': invalid dimensions %dx%d", 
                  r.name().c_str(), buf_width, buf_height);
            continue;
        }
        
        // Allocate temporary buffer for this renderable
        std::vector<uint8_t> temp_buffer(buf_width * buf_height * 4, 0);
        
        // Read the color buffer content
        renderer_->readColorBuffer(r.buffer(), 
                                   crop.left() > 0 ? crop.left() : 0,
                                   crop.top() > 0 ? crop.top() : 0,
                                   buf_width, buf_height,
                                   GL_RGBA, GL_UNSIGNED_BYTE,
                                   temp_buffer.data());
        
        // Check if we actually got data (simple check for non-zero content)
        bool has_data = false;
        for (size_t i = 0; i < temp_buffer.size() && !has_data; i += 4) {
            if (temp_buffer[i] != 0 || temp_buffer[i+1] != 0 || 
                temp_buffer[i+2] != 0 || temp_buffer[i+3] != 0) {
                has_data = true;
            }
        }
        if (!has_data && call_count <= 5) {
            WARNING("readColorBuffer for '%s' (buffer=%u) returned all zeros - "
                    "color buffer may not exist or EGL may have failed",
                    r.name().c_str(), r.buffer());
        }
        
        // Composite this buffer onto the final frame
        int dest_x = screen_pos.left();
        int dest_y = screen_pos.top();
        
        for (int y = 0; y < buf_height && dest_y + y < static_cast<int>(height); y++) {
            for (int x = 0; x < buf_width && dest_x + x < static_cast<int>(width); x++) {
                if (dest_x + x < 0 || dest_y + y < 0) continue;
                
                size_t src_offset = (y * buf_width + x) * 4;
                size_t dst_offset = ((dest_y + y) * width + (dest_x + x)) * 4;
                
                // Simple alpha blending
                uint8_t src_a = temp_buffer[src_offset + 3];
                if (src_a == 0) continue;
                
                if (src_a == 255) {
                    // Fully opaque, just copy
                    pixel_buffer_[dst_offset + 0] = temp_buffer[src_offset + 0];
                    pixel_buffer_[dst_offset + 1] = temp_buffer[src_offset + 1];
                    pixel_buffer_[dst_offset + 2] = temp_buffer[src_offset + 2];
                    pixel_buffer_[dst_offset + 3] = 255;
                } else {
                    // Alpha blend
                    uint8_t dst_a = pixel_buffer_[dst_offset + 3];
                    float alpha = src_a / 255.0f;
                    float inv_alpha = 1.0f - alpha;
                    
                    pixel_buffer_[dst_offset + 0] = static_cast<uint8_t>(
                        temp_buffer[src_offset + 0] * alpha + pixel_buffer_[dst_offset + 0] * inv_alpha);
                    pixel_buffer_[dst_offset + 1] = static_cast<uint8_t>(
                        temp_buffer[src_offset + 1] * alpha + pixel_buffer_[dst_offset + 1] * inv_alpha);
                    pixel_buffer_[dst_offset + 2] = static_cast<uint8_t>(
                        temp_buffer[src_offset + 2] * alpha + pixel_buffer_[dst_offset + 2] * inv_alpha);
                    pixel_buffer_[dst_offset + 3] = 255;
                }
            }
        }
        
        DEBUG("Composited renderable '%s' buffer=%u at (%d,%d) size %dx%d",
              r.name().c_str(), r.buffer(), dest_x, dest_y, buf_width, buf_height);
    }
    
    // Call the frame callback with the composited pixel data
    uint32_t stride = width * 4; // RGBA = 4 bytes per pixel
    frame_callback_(pixel_buffer_.data(), width, height, stride);
}

} // namespace anbox::server
