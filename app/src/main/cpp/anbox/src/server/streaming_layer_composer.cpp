/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include "server/streaming_layer_composer.h"
#include "anbox/logger.h"

namespace anbox::server {

StreamingLayerComposer::StreamingLayerComposer(
    const std::shared_ptr<::Renderer>& renderer,
    const std::shared_ptr<graphics::Rect>& rect)
    : LayerComposer(renderer, rect, nullptr),  // Pass nullptr for native_window
      renderer_(renderer),
      rect_(rect) {
    INFO("StreamingLayerComposer created for %dx%d", rect_->width(), rect_->height());
    
    // Pre-allocate pixel buffer for frame readback
    pixel_buffer_.resize(rect_->width() * rect_->height() * 4); // RGBA
}

StreamingLayerComposer::~StreamingLayerComposer() {
}

void StreamingLayerComposer::set_frame_callback(FrameCallback callback) {
    frame_callback_ = std::move(callback);
}

void StreamingLayerComposer::submit_layers(const graphics::RenderableList& renderables) {
    if (!frame_callback_) {
        // No callback set, nothing to do
        return;
    }
    
    if (!renderer_) {
        WARNING("No renderer available for frame capture");
        return;
    }
    
    uint32_t width = rect_->width();
    uint32_t height = rect_->height();
    
    // Read pixels from the current framebuffer after rendering
    // The Renderer should have already rendered the layers
    // We need to hook into the rendering process to capture frames
    
    // For now, just call the base class to render (it won't do anything without a window)
    // and signal that we would like to capture frames
    
    // TODO: Implement proper offscreen rendering
    // This requires modifying the Renderer to support offscreen targets
    // or using an EGL Pbuffer surface
    
    DEBUG("submit_layers called with %zu renderables", renderables.size());
    
    // Fill with a test pattern for now to verify the streaming works
    // In production, this would be replaced with actual frame capture
    static uint32_t frame_count = 0;
    frame_count++;
    
    // Create a simple gradient pattern
    for (uint32_t y = 0; y < height; y++) {
        for (uint32_t x = 0; x < width; x++) {
            uint32_t offset = (y * width + x) * 4;
            // RGBA
            pixel_buffer_[offset + 0] = static_cast<uint8_t>((x + frame_count) % 256);     // R
            pixel_buffer_[offset + 1] = static_cast<uint8_t>((y + frame_count) % 256);     // G
            pixel_buffer_[offset + 2] = static_cast<uint8_t>((x + y + frame_count) % 256); // B
            pixel_buffer_[offset + 3] = 255;  // A
        }
    }
    
    // Call the frame callback with the pixel data
    uint32_t stride = width * 4; // RGBA = 4 bytes per pixel
    frame_callback_(pixel_buffer_.data(), width, height, stride);
}

} // namespace anbox::server
