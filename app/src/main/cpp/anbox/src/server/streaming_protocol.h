/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#ifndef ANBOX_SERVER_STREAMING_PROTOCOL_H_
#define ANBOX_SERVER_STREAMING_PROTOCOL_H_

#include <cstdint>

namespace anbox::server {

// Protocol version for compatibility checking
constexpr uint32_t PROTOCOL_VERSION = 1;

// Default server port
constexpr uint16_t DEFAULT_PORT = 5558;

// Message types for the streaming protocol
enum class MessageType : uint8_t {
    // Handshake messages
    HANDSHAKE_REQUEST = 0x01,
    HANDSHAKE_RESPONSE = 0x02,
    
    // Graphics messages
    FRAME_DATA = 0x10,
    DISPLAY_CONFIG = 0x11,
    
    // Audio messages
    AUDIO_DATA = 0x20,
    AUDIO_CONFIG = 0x21,
    
    // Input messages
    TOUCH_EVENT = 0x30,
    KEY_EVENT = 0x31,
    MOUSE_EVENT = 0x32,
    
    // Control messages
    PING = 0x40,
    PONG = 0x41,
    DISCONNECT = 0x42,
};

// Common message header for all messages
#pragma pack(push, 1)
struct MessageHeader {
    uint32_t magic;          // Magic number for validation (0x414E4258 = "ANBX")
    uint8_t version;         // Protocol version
    MessageType type;        // Message type
    uint32_t payload_size;   // Size of payload following header
    uint32_t sequence;       // Sequence number for ordering
};

// Handshake request from client
struct HandshakeRequest {
    uint32_t client_version;
    uint32_t display_width;
    uint32_t display_height;
    uint32_t display_dpi;
};

// Handshake response from server
struct HandshakeResponse {
    uint32_t server_version;
    uint32_t result;         // 0 = success, non-zero = error code
    uint32_t display_width;
    uint32_t display_height;
    uint32_t display_dpi;
};

// Display configuration update
struct DisplayConfig {
    uint32_t width;
    uint32_t height;
    uint32_t dpi;
    uint32_t format;         // Pixel format
};

// Frame data header (followed by raw pixel data)
struct FrameHeader {
    uint32_t width;
    uint32_t height;
    uint32_t format;         // Pixel format (e.g., RGBA8888)
    uint32_t stride;         // Bytes per row
    uint64_t timestamp;      // Frame timestamp in microseconds
    uint32_t flags;          // Frame flags (e.g., keyframe, partial)
};

// Audio configuration
struct AudioConfig {
    uint32_t sample_rate;
    uint8_t channels;
    uint8_t bits_per_sample;
    uint16_t reserved;
};

// Audio data header (followed by audio samples)
struct AudioHeader {
    uint32_t size;           // Size of audio data
    uint64_t timestamp;      // Audio timestamp in microseconds
};

// Touch event
struct TouchEvent {
    int32_t x;
    int32_t y;
    int32_t finger_id;
    uint8_t action;          // 0 = down, 1 = up, 2 = move
    uint8_t reserved[3];
};

// Key event
struct KeyEvent {
    int32_t keycode;
    uint8_t action;          // 0 = down, 1 = up
    uint8_t reserved[3];
};

// Mouse event
struct MouseEvent {
    int32_t x;
    int32_t y;
    int32_t button;          // Button mask
    uint8_t action;          // 0 = move, 1 = button down, 2 = button up, 3 = scroll
    int8_t scroll_x;         // Horizontal scroll
    int8_t scroll_y;         // Vertical scroll
    uint8_t reserved;
};
#pragma pack(pop)

// Magic number for protocol validation
constexpr uint32_t PROTOCOL_MAGIC = 0x414E4258; // "ANBX"

// Frame flags
constexpr uint32_t FRAME_FLAG_KEYFRAME = 0x01;
constexpr uint32_t FRAME_FLAG_PARTIAL = 0x02;

// Touch actions
constexpr uint8_t TOUCH_ACTION_DOWN = 0;
constexpr uint8_t TOUCH_ACTION_UP = 1;
constexpr uint8_t TOUCH_ACTION_MOVE = 2;

// Key actions
constexpr uint8_t KEY_ACTION_DOWN = 0;
constexpr uint8_t KEY_ACTION_UP = 1;

// Mouse actions
constexpr uint8_t MOUSE_ACTION_MOVE = 0;
constexpr uint8_t MOUSE_ACTION_BUTTON_DOWN = 1;
constexpr uint8_t MOUSE_ACTION_BUTTON_UP = 2;
constexpr uint8_t MOUSE_ACTION_SCROLL = 3;

// Pixel formats
constexpr uint32_t PIXEL_FORMAT_RGBA8888 = 1;
constexpr uint32_t PIXEL_FORMAT_RGB888 = 2;
constexpr uint32_t PIXEL_FORMAT_RGB565 = 3;

} // namespace anbox::server

#endif // ANBOX_SERVER_STREAMING_PROTOCOL_H_
