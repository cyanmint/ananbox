/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#ifndef ANBOX_SERVER_STREAMING_SERVER_H_
#define ANBOX_SERVER_STREAMING_SERVER_H_

#include "anbox/runtime.h"
#include "anbox/graphics/renderer.h"
#include "anbox/input/device.h"
#include "anbox/network/tcp_socket_connector.h"
#include "anbox/network/connections.h"
#include "anbox/network/socket_connection.h"
#include "server/streaming_protocol.h"

#include <memory>
#include <mutex>
#include <atomic>
#include <functional>

namespace anbox::server {

class StreamingServer {
public:
    using InputEventCallback = std::function<void(const TouchEvent&)>;
    using KeyEventCallback = std::function<void(const KeyEvent&)>;

    StreamingServer(const std::shared_ptr<Runtime>& runtime,
                   const std::string& address,
                   uint16_t port);
    ~StreamingServer();

    // Start the server
    void start();

    // Stop the server
    void stop();

    // Send a frame to all connected clients
    void send_frame(const void* data, uint32_t width, uint32_t height,
                   uint32_t format, uint32_t stride);

    // Send audio data to all connected clients
    void send_audio(const void* data, uint32_t size);

    // Set display configuration
    void set_display_config(uint32_t width, uint32_t height, uint32_t dpi);

    // Set audio configuration
    void set_audio_config(uint32_t sample_rate, uint8_t channels, uint8_t bits_per_sample);

    // Set callback for input events
    void set_input_callback(InputEventCallback callback);
    void set_key_callback(KeyEventCallback callback);

    // Check if any client is connected
    bool has_clients() const;

private:
    void on_new_connection(std::shared_ptr<boost::asio::ip::tcp::socket> const& socket);
    void handle_client_message(int id, const std::vector<uint8_t>& data);
    void broadcast_message(MessageType type, const void* data, uint32_t size);

    std::shared_ptr<Runtime> runtime_;
    std::shared_ptr<network::TcpSocketConnector> connector_;
    std::shared_ptr<network::Connections<network::SocketConnection>> connections_;

    std::atomic<uint32_t> sequence_{0};
    std::atomic<int> next_id_{0};
    
    // Display config
    uint32_t display_width_{1920};
    uint32_t display_height_{1080};
    uint32_t display_dpi_{160};
    
    // Audio config
    uint32_t audio_sample_rate_{44100};
    uint8_t audio_channels_{2};
    uint8_t audio_bits_{16};
    
    // Callbacks
    InputEventCallback input_callback_;
    KeyEventCallback key_callback_;
    
    mutable std::mutex mutex_;
};

} // namespace anbox::server

#endif // ANBOX_SERVER_STREAMING_SERVER_H_
