/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * Software-only color buffer storage for headless server mode.
 */

#include "server/software_color_buffer.h"
#include "anbox/logger.h"

#include <GLES2/gl2.h>
#include <cstring>
#include <algorithm>

namespace anbox::server {

SoftwareColorBuffer::SoftwareColorBuffer(int width, int height)
    : width_(width), height_(height) {
    // Allocate RGBA buffer
    pixels_.resize(width * height * 4, 0);
    DEBUG("Created software color buffer %dx%d (%zu bytes)", 
          width, height, pixels_.size());
}

void SoftwareColorBuffer::update(int x, int y, int width, int height,
                                  uint32_t format, uint32_t type, 
                                  const void* pixels) {
    if (!pixels) return;
    
    // Currently only support RGBA/UNSIGNED_BYTE
    if (format != GL_RGBA || type != GL_UNSIGNED_BYTE) {
        // Try to handle RGB format
        if (format == GL_RGB && type == GL_UNSIGNED_BYTE) {
            const uint8_t* src = static_cast<const uint8_t*>(pixels);
            for (int row = 0; row < height && (y + row) < height_; row++) {
                for (int col = 0; col < width && (x + col) < width_; col++) {
                    if (x + col < 0 || y + row < 0) continue;
                    size_t src_offset = (row * width + col) * 3;
                    size_t dst_offset = ((y + row) * width_ + (x + col)) * 4;
                    pixels_[dst_offset + 0] = src[src_offset + 0];
                    pixels_[dst_offset + 1] = src[src_offset + 1];
                    pixels_[dst_offset + 2] = src[src_offset + 2];
                    pixels_[dst_offset + 3] = 255;
                }
            }
            return;
        }
        WARNING("Unsupported color buffer format: 0x%x type: 0x%x", format, type);
        return;
    }
    
    const uint8_t* src = static_cast<const uint8_t*>(pixels);
    
    // Copy row by row
    for (int row = 0; row < height && (y + row) < height_; row++) {
        if (y + row < 0) continue;
        
        int copy_x = std::max(0, x);
        int copy_width = std::min(width - (copy_x - x), width_ - copy_x);
        if (copy_width <= 0) continue;
        
        size_t src_offset = (row * width + (copy_x - x)) * 4;
        size_t dst_offset = ((y + row) * width_ + copy_x) * 4;
        
        std::memcpy(&pixels_[dst_offset], &src[src_offset], copy_width * 4);
    }
}

void SoftwareColorBuffer::read(int x, int y, int width, int height,
                                uint32_t format, uint32_t type,
                                void* pixels) const {
    if (!pixels) return;
    
    // Currently only support RGBA/UNSIGNED_BYTE
    if (format != GL_RGBA || type != GL_UNSIGNED_BYTE) {
        WARNING("Unsupported read format: 0x%x type: 0x%x", format, type);
        std::memset(pixels, 0, width * height * 4);
        return;
    }
    
    uint8_t* dst = static_cast<uint8_t*>(pixels);
    
    // Copy row by row
    for (int row = 0; row < height; row++) {
        int src_y = y + row;
        if (src_y < 0 || src_y >= height_) {
            std::memset(&dst[row * width * 4], 0, width * 4);
            continue;
        }
        
        for (int col = 0; col < width; col++) {
            int src_x = x + col;
            size_t dst_offset = (row * width + col) * 4;
            
            if (src_x < 0 || src_x >= width_) {
                dst[dst_offset + 0] = 0;
                dst[dst_offset + 1] = 0;
                dst[dst_offset + 2] = 0;
                dst[dst_offset + 3] = 0;
            } else {
                size_t src_offset = (src_y * width_ + src_x) * 4;
                dst[dst_offset + 0] = pixels_[src_offset + 0];
                dst[dst_offset + 1] = pixels_[src_offset + 1];
                dst[dst_offset + 2] = pixels_[src_offset + 2];
                dst[dst_offset + 3] = pixels_[src_offset + 3];
            }
        }
    }
}

// Global store

SoftwareColorBufferStore& SoftwareColorBufferStore::instance() {
    static SoftwareColorBufferStore store;
    return store;
}

uint32_t SoftwareColorBufferStore::create(int width, int height) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    uint32_t handle = next_handle_++;
    buffers_[handle] = std::make_unique<SoftwareColorBuffer>(width, height);
    
    INFO("Created software color buffer handle=%u size=%dx%d", handle, width, height);
    return handle;
}

void SoftwareColorBufferStore::destroy(uint32_t handle) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = buffers_.find(handle);
    if (it != buffers_.end()) {
        buffers_.erase(it);
        DEBUG("Destroyed software color buffer handle=%u", handle);
    }
}

bool SoftwareColorBufferStore::update(uint32_t handle, int x, int y, 
                                       int width, int height,
                                       uint32_t format, uint32_t type, 
                                       const void* pixels) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = buffers_.find(handle);
    if (it == buffers_.end()) {
        return false;
    }
    
    it->second->update(x, y, width, height, format, type, pixels);
    return true;
}

bool SoftwareColorBufferStore::read(uint32_t handle, int x, int y,
                                     int width, int height,
                                     uint32_t format, uint32_t type,
                                     void* pixels) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = buffers_.find(handle);
    if (it == buffers_.end()) {
        return false;
    }
    
    it->second->read(x, y, width, height, format, type, pixels);
    return true;
}

bool SoftwareColorBufferStore::getInfo(uint32_t handle, int* width, int* height) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = buffers_.find(handle);
    if (it == buffers_.end()) {
        return false;
    }
    
    if (width) *width = it->second->width();
    if (height) *height = it->second->height();
    return true;
}

const SoftwareColorBuffer* SoftwareColorBufferStore::get(uint32_t handle) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = buffers_.find(handle);
    if (it == buffers_.end()) {
        return nullptr;
    }
    
    return it->second.get();
}

} // namespace anbox::server
