/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include <iostream>
#include <string>
#include <csignal>
#include <cstdlib>
#include <getopt.h>

#include "anbox/graphics/emugl/Renderer.h"
#include "anbox/graphics/emugl/RenderControl.h"
#include "anbox/network/published_socket_connector.h"
#include "anbox/qemu/pipe_connection_creator.h"
#include "anbox/runtime.h"
#include "anbox/common/dispatcher.h"
#include "anbox/input/manager.h"
#include "anbox/input/device.h"
#include "anbox/graphics/layer_composer.h"
#include "anbox/logger.h"
#include "server/streaming_server.h"
#include "server/streaming_protocol.h"

#include "external/android-emugl/shared/emugl/common/logging.h"

#include <EGL/egl.h>
#include <EGL/eglext.h>

static const int MAX_TRACKING_ID = 10;
static std::shared_ptr<anbox::Runtime> runtime;
static std::shared_ptr<anbox::server::StreamingServer> streaming_server;
static std::shared_ptr<anbox::input::Device> touch_device;
static volatile bool running = true;

void logger_write(const emugl::LogLevel &level, const char *format, ...) {
    char message[2048];
    va_list args;

    va_start(args, format);
    vsnprintf(message, sizeof(message) - 1, format, args);
    va_end(args);

    switch (level) {
        case emugl::LogLevel::WARNING:
            WARNING("%s", message);
            break;
        case emugl::LogLevel::ERROR:
            ERROR("%s", message);
            break;
        case emugl::LogLevel::FATAL:
            FATAL("%s", message);
            break;
        case emugl::LogLevel::DEBUG:
            DEBUG("%s", message);
            break;
        case emugl::LogLevel::TRACE:
            TRACE("%s", message);
            break;
        default:
            break;
    }
}

void signal_handler(int signum) {
    INFO("Received signal %d, shutting down...", signum);
    running = false;
    if (runtime) {
        runtime->stop();
    }
}

void print_usage(const char* program) {
    std::cout << "Usage: " << program << " [options]\n"
              << "\n"
              << "Ananbox standalone server for Termux - runs Android containers with network streaming\n"
              << "\n"
              << "Options:\n"
              << "  -a, --address <ip>      Listen address (default: 0.0.0.0)\n"
              << "  -p, --port <port>       Listen port (default: " << anbox::server::DEFAULT_PORT << ")\n"
              << "  -w, --width <pixels>    Display width (default: 1280)\n"
              << "  -h, --height <pixels>   Display height (default: 720)\n"
              << "  -d, --dpi <dpi>         Display DPI (default: 160)\n"
              << "  -r, --rootfs <path>     Path to rootfs directory (default: $HOME/rootfs)\n"
              << "  -P, --proot <path>      Path to proot binary (default: proot in PATH)\n"
              << "  -v, --verbose           Enable verbose logging\n"
              << "  --help                  Show this help message\n"
              << "\n"
              << "Example (in Termux):\n"
              << "  " << program << " -a 0.0.0.0 -p 5558 -w 1920 -h 1080 -r ~/rootfs\n"
              << std::endl;
}

int main(int argc, char* argv[]) {
    // Default paths suitable for Termux
    std::string home = getenv("HOME") ? getenv("HOME") : ".";
    std::string listen_address = "0.0.0.0";
    uint16_t listen_port = anbox::server::DEFAULT_PORT;
    int display_width = 1280;
    int display_height = 720;
    int display_dpi = 160;
    std::string rootfs_path = home + "/rootfs";
    std::string proot_path = "proot";  // Assume proot is in PATH
    bool verbose = false;

    static struct option long_options[] = {
        {"address", required_argument, 0, 'a'},
        {"port",    required_argument, 0, 'p'},
        {"width",   required_argument, 0, 'w'},
        {"height",  required_argument, 0, 'h'},
        {"dpi",     required_argument, 0, 'd'},
        {"rootfs",  required_argument, 0, 'r'},
        {"proot",   required_argument, 0, 'P'},
        {"verbose", no_argument,       0, 'v'},
        {"help",    no_argument,       0, 0},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;
    while ((opt = getopt_long(argc, argv, "a:p:w:h:d:r:P:v", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'a':
                listen_address = optarg;
                break;
            case 'p':
                listen_port = static_cast<uint16_t>(std::stoi(optarg));
                break;
            case 'w':
                display_width = std::stoi(optarg);
                break;
            case 'h':
                display_height = std::stoi(optarg);
                break;
            case 'd':
                display_dpi = std::stoi(optarg);
                break;
            case 'r':
                rootfs_path = optarg;
                break;
            case 'P':
                proot_path = optarg;
                break;
            case 'v':
                verbose = true;
                break;
            case 0:
                if (std::string(long_options[option_index].name) == "help") {
                    print_usage(argv[0]);
                    return 0;
                }
                break;
            default:
                print_usage(argv[0]);
                return 1;
        }
    }

    // Setup signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    INFO("Ananbox Server starting...");
    INFO("  Listen: %s:%d", listen_address.c_str(), listen_port);
    INFO("  Display: %dx%d @ %d DPI", display_width, display_height, display_dpi);
    INFO("  Rootfs: %s", rootfs_path.c_str());
    INFO("  Proot: %s", proot_path.c_str());

    // Setup EGL logging
    set_emugl_logger(logger_write);
    set_emugl_cxt_logger(logger_write);

    // Initialize runtime
    runtime = anbox::Runtime::create();

    // Initialize renderer with offscreen EGL context
    auto renderer = std::make_shared<::Renderer>();
    if (!renderer->initialize(EGL_DEFAULT_DISPLAY)) {
        ERROR("Failed to initialize renderer");
        return 1;
    }
    registerRenderer(renderer);

    // Create streaming server
    streaming_server = std::make_shared<anbox::server::StreamingServer>(
        runtime, listen_address, listen_port);
    streaming_server->set_display_config(display_width, display_height, display_dpi);

    // Create input manager
    auto input_manager = std::make_shared<anbox::input::Manager>(
        runtime, rootfs_path + "/dev/input");

    // Setup touch device
    touch_device = input_manager->create_device();
    touch_device->set_name("anbox-touch");
    touch_device->set_driver_version(1);
    touch_device->set_input_id({BUS_VIRTUAL, 4, 4, 4});
    touch_device->set_physical_location("none");
    touch_device->set_abs_bit(ABS_MT_SLOT);
    touch_device->set_abs_max(ABS_MT_SLOT, 10);
    touch_device->set_abs_bit(ABS_MT_TOUCH_MAJOR);
    touch_device->set_abs_max(ABS_MT_TOUCH_MAJOR, 127);
    touch_device->set_abs_bit(ABS_MT_TOUCH_MINOR);
    touch_device->set_abs_max(ABS_MT_TOUCH_MINOR, 127);
    touch_device->set_abs_bit(ABS_MT_POSITION_X);
    touch_device->set_abs_max(ABS_MT_POSITION_X, display_width);
    touch_device->set_abs_bit(ABS_MT_POSITION_Y);
    touch_device->set_abs_max(ABS_MT_POSITION_Y, display_height);
    touch_device->set_abs_bit(ABS_MT_TRACKING_ID);
    touch_device->set_abs_max(ABS_MT_TRACKING_ID, MAX_TRACKING_ID);
    touch_device->set_prop_bit(INPUT_PROP_DIRECT);

    // Setup input callback from streaming server
    streaming_server->set_input_callback([](const anbox::server::TouchEvent& event) {
        if (!touch_device) return;
        
        std::vector<anbox::input::Event> touch_events;
        
        switch (event.action) {
            case anbox::server::TOUCH_ACTION_DOWN:
                touch_events.push_back({EV_ABS, ABS_MT_SLOT, event.finger_id});
                touch_events.push_back({EV_ABS, ABS_MT_TRACKING_ID, event.finger_id + 1});
                touch_events.push_back({EV_ABS, ABS_MT_POSITION_X, event.x});
                touch_events.push_back({EV_ABS, ABS_MT_POSITION_Y, event.y});
                touch_events.push_back({EV_SYN, SYN_REPORT, 0});
                break;
                
            case anbox::server::TOUCH_ACTION_UP:
                touch_events.push_back({EV_ABS, ABS_MT_SLOT, event.finger_id});
                touch_events.push_back({EV_ABS, ABS_MT_TRACKING_ID, -1});
                touch_events.push_back({EV_SYN, SYN_REPORT, 0});
                break;
                
            case anbox::server::TOUCH_ACTION_MOVE:
                touch_events.push_back({EV_ABS, ABS_MT_SLOT, event.finger_id});
                touch_events.push_back({EV_ABS, ABS_MT_POSITION_X, event.x});
                touch_events.push_back({EV_ABS, ABS_MT_POSITION_Y, event.y});
                touch_events.push_back({EV_SYN, SYN_REPORT, 0});
                break;
        }
        
        if (!touch_events.empty()) {
            touch_device->send_events(touch_events);
        }
    });

    // Setup sensors and GPS
    auto sensors_state = std::make_shared<anbox::application::SensorsState>();
    auto gps_info_broker = std::make_shared<anbox::application::GpsInfoBroker>();

    // Create QEMU pipe connector
    std::string socket_file = rootfs_path + "/qemu_pipe";
    unlink(socket_file.c_str());
    
    auto qemu_pipe_connector = std::make_shared<anbox::network::PublishedSocketConnector>(
        socket_file, runtime,
        std::make_shared<anbox::qemu::PipeConnectionCreator>(
            renderer, runtime, sensors_state, gps_info_broker));

    // Start the streaming server
    streaming_server->start();

    // Start runtime
    runtime->start();

    INFO("Server is running. Press Ctrl+C to stop.");

    // Start the container if proot is available
    std::string run_script = rootfs_path + "/run.sh";
    if (access(run_script.c_str(), F_OK) == 0) {
        INFO("Starting container...");
        pid_t pid = fork();
        if (pid == 0) {
            // Child process
            sigset_t signals_to_unblock;
            sigfillset(&signals_to_unblock);
            sigprocmask(SIG_UNBLOCK, &signals_to_unblock, 0);
            
            // Use execv with proper argument separation to avoid shell injection
            const char* args[] = {
                "/system/bin/sh",
                run_script.c_str(),
                rootfs_path.c_str(),
                proot_path.c_str(),
                nullptr
            };
            execv("/system/bin/sh", const_cast<char* const*>(args));
            // Fallback to /bin/sh if /system/bin/sh doesn't exist
            args[0] = "/bin/sh";
            execv("/bin/sh", const_cast<char* const*>(args));
            ERROR("Failed to start container: %s", strerror(errno));
            exit(1);
        }
    } else {
        WARNING("Container run script not found at %s, running server only", run_script.c_str());
    }

    // Main loop - wait for shutdown
    while (running) {
        sleep(1);
    }

    // Cleanup
    INFO("Shutting down...");
    streaming_server->stop();
    runtime->stop();
    renderer->finalize();

    INFO("Server stopped.");
    return 0;
}
