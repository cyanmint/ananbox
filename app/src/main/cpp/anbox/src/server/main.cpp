/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include <iostream>
#include <string>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <getopt.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/stat.h>

#include "anbox/logger.h"
#include "server/streaming_server.h"
#include "server/streaming_protocol.h"

static volatile bool running = true;
static pid_t container_pid = -1;

void signal_handler(int signum) {
    INFO("Received signal %d, shutting down...", signum);
    running = false;
    
    // Forward signal to child process if running
    if (container_pid > 0) {
        kill(container_pid, signum);
    }
}

void print_usage(const char* program) {
    std::cout << "Usage: " << program << " [options]\n"
              << "\n"
              << "Ananbox standalone server for Termux - runs Android containers with network streaming\n"
              << "\n"
              << "Options:\n"
              << "  -a, --address <ip>      Listen address (default: 0.0.0.0)\n"
              << "  -p, --port <port>       Listen port (default: " << anbox::server::DEFAULT_PORT << ")\n"
              << "  -w, --width <pixels>    Display width (default: 1280)\n"
              << "  -h, --height <pixels>   Display height (default: 720)\n"
              << "  -d, --dpi <dpi>         Display DPI (default: 160)\n"
              << "  -r, --rootfs <path>     Path to rootfs directory (default: $HOME/rootfs)\n"
              << "  -P, --proot <path>      Path to proot binary (default: proot in PATH)\n"
              << "  -s, --script <path>     Path to startup script (default: rootfs/run.sh)\n"
              << "  -v, --verbose           Enable verbose logging\n"
              << "  --help                  Show this help message\n"
              << "\n"
              << "Example (in Termux):\n"
              << "  " << program << " -a 0.0.0.0 -p 5558 -w 1920 -h 1080 -r ~/rootfs\n"
              << std::endl;
}

// Normalize a path - removes trailing slashes and handles relative paths
std::string normalize_path(const std::string& path) {
    std::string result = path;
    
    // Remove trailing slashes
    while (result.length() > 1 && result.back() == '/') {
        result.pop_back();
    }
    
    return result;
}

int main(int argc, char* argv[]) {
    // Default paths suitable for Termux
    const char* home_env = getenv("HOME");
    std::string home = home_env ? home_env : "/data/data/com.termux/files/home";
    std::string listen_address = "0.0.0.0";
    uint16_t listen_port = anbox::server::DEFAULT_PORT;
    int display_width = 1280;
    int display_height = 720;
    int display_dpi = 160;
    std::string rootfs_path = home + "/rootfs";
    std::string proot_path = "proot";  // Assume proot is in PATH
    std::string startup_script;  // Will default to rootfs/run.sh if not specified
    bool verbose = false;

    static struct option long_options[] = {
        {"address", required_argument, 0, 'a'},
        {"port",    required_argument, 0, 'p'},
        {"width",   required_argument, 0, 'w'},
        {"height",  required_argument, 0, 'h'},
        {"dpi",     required_argument, 0, 'd'},
        {"rootfs",  required_argument, 0, 'r'},
        {"proot",   required_argument, 0, 'P'},
        {"script",  required_argument, 0, 's'},
        {"verbose", no_argument,       0, 'v'},
        {"help",    no_argument,       0, 0},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;
    while ((opt = getopt_long(argc, argv, "a:p:w:h:d:r:P:s:v", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'a':
                listen_address = optarg;
                break;
            case 'p':
                listen_port = static_cast<uint16_t>(std::stoi(optarg));
                break;
            case 'w':
                display_width = std::stoi(optarg);
                break;
            case 'h':
                display_height = std::stoi(optarg);
                break;
            case 'd':
                display_dpi = std::stoi(optarg);
                break;
            case 'r':
                rootfs_path = normalize_path(optarg);
                break;
            case 'P':
                proot_path = optarg;
                break;
            case 's':
                startup_script = optarg;
                break;
            case 'v':
                verbose = true;
                break;
            case 0:
                if (std::string(long_options[option_index].name) == "help") {
                    print_usage(argv[0]);
                    return 0;
                }
                break;
            default:
                print_usage(argv[0]);
                return 1;
        }
    }

    // Setup signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    signal(SIGCHLD, SIG_IGN);  // Ignore child exit to avoid zombies

    // Validate paths to prevent path traversal attacks
    auto validate_path = [](const std::string& path, const std::string& name) -> bool {
        // Check for null bytes
        if (path.find('\0') != std::string::npos) {
            ERROR("Invalid %s path: contains null byte", name.c_str());
            return false;
        }
        // Check for path traversal attempts
        if (path.find("..") != std::string::npos) {
            ERROR("Invalid %s path: contains '..'", name.c_str());
            return false;
        }
        // Path should not be empty
        if (path.empty()) {
            ERROR("Invalid %s path: empty", name.c_str());
            return false;
        }
        return true;
    };
    
    if (!validate_path(rootfs_path, "rootfs") || !validate_path(proot_path, "proot")) {
        return 1;
    }

    // Normalize rootfs path to remove any trailing slashes
    rootfs_path = normalize_path(rootfs_path);

    // Check if rootfs directory exists
    struct stat st;
    if (stat(rootfs_path.c_str(), &st) != 0 || !S_ISDIR(st.st_mode)) {
        ERROR("Rootfs directory does not exist: %s", rootfs_path.c_str());
        return 1;
    }

    // Set default startup script if not specified
    if (startup_script.empty()) {
        startup_script = rootfs_path + "/run.sh";
    }

    INFO("Ananbox Server starting...");
    INFO("  Listen: %s:%d", listen_address.c_str(), listen_port);
    INFO("  Display: %dx%d @ %d DPI", display_width, display_height, display_dpi);
    INFO("  Rootfs: %s", rootfs_path.c_str());
    INFO("  Proot: %s", proot_path.c_str());
    INFO("  Startup script: %s", startup_script.c_str());

    // Note: In Termux standalone mode, we skip EGL/renderer initialization
    // as we don't have a display. The server will just forward streaming data.
    INFO("Running in headless mode (no GPU rendering)");

    // Start the container if startup script is available
    if (access(startup_script.c_str(), F_OK) == 0) {
        INFO("Starting container using script: %s", startup_script.c_str());
        container_pid = fork();
        if (container_pid < 0) {
            ERROR("fork() failed: %s", strerror(errno));
            return 1;
        } else if (container_pid == 0) {
            // Child process
            sigset_t signals_to_unblock;
            sigfillset(&signals_to_unblock);
            sigprocmask(SIG_UNBLOCK, &signals_to_unblock, 0);
            
            // Change to rootfs directory
            if (chdir(rootfs_path.c_str()) != 0) {
                fprintf(stderr, "Failed to change to rootfs directory: %s\n", strerror(errno));
                exit(1);
            }
            
            // Use execv with proper argument separation to avoid shell injection
            // The script receives: $0=script, $1=rootfs_path, $2=proot_path
            const char* args[] = {
                startup_script.c_str(),
                rootfs_path.c_str(),
                proot_path.c_str(),
                nullptr
            };
            
            // Try to execute the script directly first
            execv(startup_script.c_str(), const_cast<char* const*>(args));
            
            // If that fails, try with bash
            const char* bash_args[] = {
                "bash",
                startup_script.c_str(),
                rootfs_path.c_str(),
                proot_path.c_str(),
                nullptr
            };
            execvp("bash", const_cast<char* const*>(bash_args));
            
            // If that fails, try with sh
            bash_args[0] = "sh";
            execvp("sh", const_cast<char* const*>(bash_args));
            
            fprintf(stderr, "Failed to start container: %s\n", strerror(errno));
            exit(1);
        } else {
            // Parent process
            INFO("Container process started with PID %d", container_pid);
        }
    } else {
        INFO("Startup script not found at %s", startup_script.c_str());
        INFO("Running server only (no container). Use -s to specify a startup script.");
    }

    INFO("Server is running. Press Ctrl+C to stop.");

    // Main loop - wait for shutdown or child exit
    while (running) {
        if (container_pid > 0) {
            // Check if child process is still running
            int status;
            pid_t result = waitpid(container_pid, &status, WNOHANG);
            if (result == container_pid) {
                if (WIFEXITED(status)) {
                    INFO("Container exited with code %d", WEXITSTATUS(status));
                } else if (WIFSIGNALED(status)) {
                    INFO("Container killed by signal %d", WTERMSIG(status));
                }
                container_pid = -1;
                // Don't exit, keep server running
            } else if (result < 0 && errno != ECHILD) {
                ERROR("waitpid failed: %s", strerror(errno));
            }
        }
        sleep(1);
    }

    // Cleanup
    INFO("Shutting down...");
    
    // Kill container if still running
    if (container_pid > 0) {
        INFO("Stopping container (PID %d)...", container_pid);
        kill(container_pid, SIGTERM);
        int status;
        waitpid(container_pid, &status, 0);
    }

    INFO("Server stopped.");
    return 0;
}
