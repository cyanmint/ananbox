/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include <iostream>
#include <string>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <getopt.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <limits.h>
#include <thread>
#include <linux/input.h>

#include "anbox/logger.h"
#include "anbox/runtime.h"
#include "anbox/graphics/emugl/Renderer.h"
#include "anbox/graphics/emugl/RenderApi.h"
#include "anbox/graphics/emugl/RenderControl.h"
#include "anbox/graphics/emugl/DisplayManager.h"
#include "anbox/graphics/layer_composer.h"
#include "anbox/network/published_socket_connector.h"
#include "anbox/qemu/pipe_connection_creator.h"
#include "anbox/input/manager.h"
#include "anbox/input/device.h"
#include "anbox/application/sensors_state.h"
#include "anbox/application/gps_info_broker.h"
#include "external/android-emugl/shared/emugl/common/logging.h"
#include "server/streaming_server.h"
#include "server/streaming_protocol.h"
#include "server/streaming_layer_composer.h"

static volatile bool running = true;
static pid_t container_pid = -1;

// Anbox runtime components
static std::shared_ptr<anbox::Runtime> rt;
static std::shared_ptr<::Renderer> renderer_;
static std::shared_ptr<anbox::network::PublishedSocketConnector> qemu_pipe_connector_;
static std::shared_ptr<anbox::input::Device> touch_;
static std::shared_ptr<anbox::graphics::Rect> frame;
static std::shared_ptr<anbox::server::StreamingLayerComposer> streaming_composer_;

// Logging callback for emugl (assigns to extern logger_t emugl_logger from logging.h)
static void server_emugl_logger(const emugl::LogLevel& level, const char* format, ...) {
    char message[2048];
    va_list args;
    va_start(args, format);
    vsnprintf(message, sizeof(message) - 1, format, args);
    va_end(args);
    
    switch (level) {
        case emugl::LogLevel::WARNING:
            WARNING("%s", message);
            break;
        case emugl::LogLevel::ERROR:
        case emugl::LogLevel::FATAL:
            ERROR("%s", message);
            break;
        case emugl::LogLevel::DEBUG:
            DEBUG("%s", message);
            break;
        default:
            break;
    }
}

void signal_handler(int signum) {
    INFO("Received signal %d, shutting down...", signum);
    running = false;
    
    // Forward signal to child process if running
    if (container_pid > 0) {
        kill(container_pid, signum);
    }
}

void print_usage(const char* program) {
    std::cout << "Usage: " << program << " [options]\n"
              << "\n"
              << "Ananbox standalone server for Termux - runs Android containers with network streaming\n"
              << "\n"
              << "Options:\n"
              << "  -a, --address <ip>      Listen address (default: 0.0.0.0)\n"
              << "  -p, --port <port>       Listen port (default: " << anbox::server::DEFAULT_PORT << ")\n"
              << "  -w, --width <pixels>    Display width (default: 1280)\n"
              << "  -h, --height <pixels>   Display height (default: 720)\n"
              << "  -d, --dpi <dpi>         Display DPI (default: 160)\n"
              << "  -b, --base <path>       Base path (parent of rootfs, default: current directory)\n"
              << "  -P, --proot <path>      Path to proot/libproot.so (default: ./libproot.so)\n"
              << "  -s, --script <path>     Path to startup script (default: <base>/rootfs/run.sh)\n"
              << "  -t, --tmpdir <path>     Temporary directory for proot (default: <base>/tmp)\n"
              << "  -v, --verbose           Enable verbose logging\n"
              << "  --help                  Show this help message\n"
              << "\n"
              << "The base path should contain:\n"
              << "  - rootfs/         Android rootfs directory\n"
              << "  - rootfs/run.sh   Container startup script\n"
              << "\n"
              << "Example (in Termux):\n"
              << "  cd /data/data/com.termux/ananbox\n"
              << "  ./ananbox-server -b . -P ./libproot.so\n"
              << std::endl;
}

// Normalize a path - removes trailing slashes and handles relative paths
std::string normalize_path(const std::string& path) {
    std::string result = path;
    
    // Remove trailing slashes
    while (result.length() > 1 && result.back() == '/') {
        result.pop_back();
    }
    
    return result;
}

// Get the parent directory of a path
std::string get_parent_dir(const std::string& path) {
    size_t pos = path.rfind('/');
    if (pos == std::string::npos || pos == 0) {
        return ".";
    }
    return path.substr(0, pos);
}

// Create directory if it doesn't exist
bool ensure_directory(const std::string& path) {
    struct stat st;
    if (stat(path.c_str(), &st) == 0) {
        return S_ISDIR(st.st_mode);
    }
    return mkdir(path.c_str(), 0755) == 0;
}

int main(int argc, char* argv[]) {
    // Get current working directory as default base
    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd)) == nullptr) {
        ERROR("Failed to get current directory");
        return 1;
    }
    
    std::string listen_address = "0.0.0.0";
    uint16_t listen_port = anbox::server::DEFAULT_PORT;
    int display_width = 1280;
    int display_height = 720;
    int display_dpi = 160;
    std::string base_path = cwd;  // Default to current directory
    std::string proot_path = "./libproot.so";  // Default to local libproot.so
    std::string startup_script;  // Will default to <base>/rootfs/run.sh if not specified
    std::string tmp_dir;  // Will default to <base>/tmp if not specified
    bool verbose = false;

    static struct option long_options[] = {
        {"address", required_argument, 0, 'a'},
        {"port",    required_argument, 0, 'p'},
        {"width",   required_argument, 0, 'w'},
        {"height",  required_argument, 0, 'h'},
        {"dpi",     required_argument, 0, 'd'},
        {"base",    required_argument, 0, 'b'},
        {"proot",   required_argument, 0, 'P'},
        {"script",  required_argument, 0, 's'},
        {"tmpdir",  required_argument, 0, 't'},
        {"verbose", no_argument,       0, 'v'},
        {"help",    no_argument,       0, 0},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;
    while ((opt = getopt_long(argc, argv, "a:p:w:h:d:b:P:s:t:v", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'a':
                listen_address = optarg;
                break;
            case 'p':
                listen_port = static_cast<uint16_t>(std::stoi(optarg));
                break;
            case 'w':
                display_width = std::stoi(optarg);
                break;
            case 'h':
                display_height = std::stoi(optarg);
                break;
            case 'd':
                display_dpi = std::stoi(optarg);
                break;
            case 'b':
                base_path = normalize_path(optarg);
                break;
            case 'P':
                proot_path = optarg;
                break;
            case 's':
                startup_script = optarg;
                break;
            case 't':
                tmp_dir = optarg;
                break;
            case 'v':
                verbose = true;
                break;
            case 0:
                if (std::string(long_options[option_index].name) == "help") {
                    print_usage(argv[0]);
                    return 0;
                }
                break;
            default:
                print_usage(argv[0]);
                return 1;
        }
    }

    // Setup signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    signal(SIGCHLD, SIG_IGN);  // Ignore child exit to avoid zombies

    // Validate paths to prevent path traversal attacks
    auto validate_path = [](const std::string& path, const std::string& name) -> bool {
        // Check for null bytes
        if (path.find('\0') != std::string::npos) {
            ERROR("Invalid %s path: contains null byte", name.c_str());
            return false;
        }
        // Path should not be empty
        if (path.empty()) {
            ERROR("Invalid %s path: empty", name.c_str());
            return false;
        }
        return true;
    };
    
    if (!validate_path(base_path, "base") || !validate_path(proot_path, "proot")) {
        return 1;
    }

    // Normalize base path
    base_path = normalize_path(base_path);

    // Check if base directory exists
    struct stat st;
    if (stat(base_path.c_str(), &st) != 0 || !S_ISDIR(st.st_mode)) {
        ERROR("Base directory does not exist: %s", base_path.c_str());
        return 1;
    }

    // Construct rootfs path from base
    std::string rootfs_path = base_path + "/rootfs";
    
    // Check if rootfs directory exists
    if (stat(rootfs_path.c_str(), &st) != 0 || !S_ISDIR(st.st_mode)) {
        ERROR("Rootfs directory does not exist: %s", rootfs_path.c_str());
        ERROR("Expected rootfs at: %s/rootfs", base_path.c_str());
        return 1;
    }

    // Set default startup script if not specified
    if (startup_script.empty()) {
        startup_script = rootfs_path + "/run.sh";
    }

    // Set default tmp directory if not specified
    if (tmp_dir.empty()) {
        tmp_dir = base_path + "/tmp";
    }
    
    // Create tmp directory if it doesn't exist
    if (!ensure_directory(tmp_dir)) {
        ERROR("Failed to create temporary directory: %s", tmp_dir.c_str());
        return 1;
    }
    
    // Also create tmp inside rootfs for proot
    std::string rootfs_tmp = rootfs_path + "/tmp";
    ensure_directory(rootfs_tmp);

    INFO("========================================");
    INFO("Ananbox Server starting...");
    INFO("========================================");
    INFO("Configuration:");
    INFO("  Listen address: %s", listen_address.c_str());
    INFO("  Listen port:    %d", listen_port);
    INFO("  Display width:  %d", display_width);
    INFO("  Display height: %d", display_height);
    INFO("  Display DPI:    %d", display_dpi);
    INFO("  Base path:      %s", base_path.c_str());
    INFO("  Rootfs:         %s", rootfs_path.c_str());
    INFO("  Proot:          %s", proot_path.c_str());
    INFO("  Temp dir:       %s", tmp_dir.c_str());
    INFO("  Startup script: %s", startup_script.c_str());
    INFO("========================================");

    // Initialize emugl logging
    INFO("Initializing emugl logging...");
    set_emugl_logger(server_emugl_logger);
    set_emugl_cxt_logger(server_emugl_logger);

    // Create runtime for async I/O
    INFO("Creating async I/O runtime...");
    rt = anbox::Runtime::create();
    INFO("Runtime created successfully");

    // Initialize the Renderer (OpenGL ES emulation)
    INFO("Initializing OpenGL ES renderer...");
    renderer_ = std::make_shared<::Renderer>();
    frame = std::make_shared<anbox::graphics::Rect>();
    frame->resize(display_width, display_height);
    
    auto display_info = anbox::graphics::emugl::DisplayInfo::get();
    display_info->set_resolution(display_width, display_height);
    display_info->set_dpi(display_dpi);
    INFO("Display info configured: %dx%d @ %d DPI", display_width, display_height, display_dpi);

    // Initialize renderer with default display (may fail in headless mode)
    INFO("Attempting EGL initialization...");
    bool egl_initialized = renderer_->initialize(EGL_DEFAULT_DISPLAY);
    if (!egl_initialized) {
        WARNING("========================================");
        WARNING("EGL initialization failed!");
        WARNING("Running in software-only mode.");
        WARNING("========================================");
        INFO("In this mode:");
        INFO("  - Test pattern frames will be sent to clients");
        INFO("  - Container graphics require EGL/swiftshader");
        INFO("  - Install swiftshader in Termux for full graphics support");
        // Enable software renderer mode - stores color buffers in memory
        enableSoftwareRenderer(true);
    } else {
        INFO("========================================");
        INFO("EGL initialized successfully!");
        INFO("Container graphics will be captured and streamed.");
        INFO("========================================");
        // Register renderer for use
        registerRenderer(renderer_);
    }

    // Create streaming server
    std::shared_ptr<anbox::server::StreamingServer> streaming_server;
    
    try {
        // Start the runtime (this spawns worker threads for async I/O)
        INFO("Starting async I/O runtime...");
        rt->start();
        INFO("Runtime started successfully");
        
        // Create streaming server
        INFO("Creating streaming server...");
        streaming_server = std::make_shared<anbox::server::StreamingServer>(
            rt, listen_address, listen_port);
        
        // Set display configuration
        streaming_server->set_display_config(display_width, display_height, display_dpi);
        INFO("Streaming server created");
        
        // Create streaming layer composer that will capture frames and send to clients
        // Pass nullptr for renderer when using software mode - it will use SoftwareColorBufferStore
        INFO("Creating streaming layer composer...");
        streaming_composer_ = std::make_shared<anbox::server::StreamingLayerComposer>(
            egl_initialized ? renderer_ : nullptr, frame);
        streaming_composer_->set_frame_callback(
            [streaming_server](const void* data, uint32_t width, uint32_t height, uint32_t stride) {
                streaming_server->send_frame(data, width, height, 
                    anbox::server::PIXEL_FORMAT_RGBA8888, stride);
            });
        INFO("Layer composer created and frame callback registered");
        
        // Register the streaming layer composer
        registerLayerComposer(streaming_composer_);
        INFO("Layer composer registered with RenderControl");
        
        // Start the streaming server
        streaming_server->start();
        
        INFO("========================================");
        INFO("Streaming server ready!");
        INFO("Listening on %s:%d", listen_address.c_str(), listen_port);
        INFO("Waiting for client connections...");
        INFO("========================================");
    } catch (const std::exception& e) {
        ERROR("Failed to start streaming server: %s", e.what());
        // Kill container if running
        if (container_pid > 0) {
            kill(container_pid, SIGTERM);
        }
        if (rt) {
            rt->stop();
        }
        return 1;
    }

    // Initialize input manager for touch/key events from clients
    INFO("Setting up input device manager...");
    auto input_manager = std::make_shared<anbox::input::Manager>(
        rt, anbox::utils::string_format("%s/dev/input", rootfs_path.c_str()));
    
    touch_ = input_manager->create_device();
    touch_->set_name("anbox-touch");
    touch_->set_driver_version(1);
    touch_->set_input_id({BUS_VIRTUAL, 4, 4, 4});
    touch_->set_physical_location("none");
    touch_->set_abs_bit(ABS_MT_SLOT);
    touch_->set_abs_max(ABS_MT_SLOT, 10);
    touch_->set_abs_bit(ABS_MT_TOUCH_MAJOR);
    touch_->set_abs_max(ABS_MT_TOUCH_MAJOR, 127);
    touch_->set_abs_bit(ABS_MT_TOUCH_MINOR);
    touch_->set_abs_max(ABS_MT_TOUCH_MINOR, 127);
    touch_->set_abs_bit(ABS_MT_POSITION_X);
    touch_->set_abs_max(ABS_MT_POSITION_X, display_width);
    touch_->set_abs_bit(ABS_MT_POSITION_Y);
    touch_->set_abs_max(ABS_MT_POSITION_Y, display_height);
    touch_->set_abs_bit(ABS_MT_TRACKING_ID);
    touch_->set_abs_max(ABS_MT_TRACKING_ID, 10);
    touch_->set_prop_bit(INPUT_PROP_DIRECT);
    INFO("Touch input device created: anbox-touch (supports %d fingers)", 10);

    // Set up input callback from streaming server
    streaming_server->set_input_callback(
        [](const anbox::server::TouchEvent& event) {
            if (!touch_) return;
            std::vector<anbox::input::Event> touch_events;
            
            // Handle slot
            static int last_slot = -1;
            int slot = event.finger_id % 10;
            if (last_slot != slot) {
                touch_events.push_back({EV_ABS, ABS_MT_SLOT, slot});
                last_slot = slot;
            }
            
            switch (event.action) {
                case anbox::server::TOUCH_ACTION_DOWN:
                    DEBUG("Touch DOWN: finger=%d pos=(%d,%d)", event.finger_id, event.x, event.y);
                    touch_events.push_back({EV_ABS, ABS_MT_TRACKING_ID, static_cast<int32_t>(event.finger_id % 10 + 1)});
                    touch_events.push_back({EV_ABS, ABS_MT_POSITION_X, static_cast<int32_t>(event.x)});
                    touch_events.push_back({EV_ABS, ABS_MT_POSITION_Y, static_cast<int32_t>(event.y)});
                    break;
                case anbox::server::TOUCH_ACTION_MOVE:
                    touch_events.push_back({EV_ABS, ABS_MT_POSITION_X, static_cast<int32_t>(event.x)});
                    touch_events.push_back({EV_ABS, ABS_MT_POSITION_Y, static_cast<int32_t>(event.y)});
                    break;
                case anbox::server::TOUCH_ACTION_UP:
                    DEBUG("Touch UP: finger=%d", event.finger_id);
                    touch_events.push_back({EV_ABS, ABS_MT_TRACKING_ID, -1});
                    break;
            }
            
            touch_events.push_back({EV_SYN, SYN_REPORT, 0});
            touch_->send_events(touch_events);
        });
    INFO("Touch input callback registered");

    // Initialize qemu_pipe for Android container communication
    INFO("Setting up qemu_pipe for container communication...");
    auto sensors_state = std::make_shared<anbox::application::SensorsState>();
    auto gps_info_broker = std::make_shared<anbox::application::GpsInfoBroker>();
    
    std::string socket_file = anbox::utils::string_format("%s/qemu_pipe", base_path.c_str());
    unlink(socket_file.c_str());  // Remove old socket if exists
    
    qemu_pipe_connector_ = std::make_shared<anbox::network::PublishedSocketConnector>(
        socket_file, rt,
        std::make_shared<anbox::qemu::PipeConnectionCreator>(
            renderer_, rt, sensors_state, gps_info_broker));
    INFO("qemu_pipe socket created at: %s", socket_file.c_str());

    // Start the container if startup script is available
    if (access(startup_script.c_str(), F_OK) == 0) {
        INFO("========================================");
        INFO("Starting Android container...");
        INFO("Script: %s", startup_script.c_str());
        INFO("========================================");
        container_pid = fork();
        if (container_pid < 0) {
            ERROR("fork() failed: %s", strerror(errno));
            rt->stop();
            return 1;
        } else if (container_pid == 0) {
            // Child process
            sigset_t signals_to_unblock;
            sigfillset(&signals_to_unblock);
            sigprocmask(SIG_UNBLOCK, &signals_to_unblock, 0);
            
            // Change to base directory (same as app behavior)
            if (chdir(base_path.c_str()) != 0) {
                fprintf(stderr, "Failed to change to base directory: %s\n", strerror(errno));
                exit(1);
            }
            
            // Set PROOT_TMP_DIR environment variable
            setenv("PROOT_TMP_DIR", tmp_dir.c_str(), 1);
            
            // Execute the script the same way as the app does:
            // sh $base_path/rootfs/run.sh $base_path $proot_path
            // The script expects: $1 = base_path (parent of rootfs), $2 = proot_path
            const char* args[] = {
                "sh",
                startup_script.c_str(),
                base_path.c_str(),
                proot_path.c_str(),
                nullptr
            };
            
            execvp("sh", const_cast<char* const*>(args));
            
            fprintf(stderr, "Failed to start container: %s\n", strerror(errno));
            exit(1);
        } else {
            // Parent process
            INFO("Container process started with PID %d", container_pid);
            INFO("Container is initializing... This may take a few seconds.");
        }
    } else {
        WARNING("========================================");
        WARNING("Startup script not found: %s", startup_script.c_str());
        WARNING("Running in server-only mode (no container).");
        WARNING("Use -s to specify a startup script.");
        WARNING("========================================");
    }

    INFO("========================================");
    INFO("Server is running!");
    INFO("Press Ctrl+C to stop.");
    INFO("========================================");
    
    // If EGL failed, we need to send test frames to show the streaming works
    // The container's OpenGL commands won't work without EGL
    bool send_test_frames = !egl_initialized;
    if (send_test_frames) {
        INFO("EGL not available - sending test pattern frames to verify streaming");
        INFO("Note: Container graphics require EGL/swiftshader to work in headless mode");
    }
    
    // Test frame buffer for when EGL is not available
    std::vector<uint8_t> test_frame;
    int test_frame_counter = 0;
    if (send_test_frames) {
        test_frame.resize(display_width * display_height * 4);
    }

    // Main loop - wait for shutdown or child exit
    while (running) {
        if (container_pid > 0) {
            // Check if child process is still running
            int status;
            pid_t result = waitpid(container_pid, &status, WNOHANG);
            if (result == container_pid) {
                if (WIFEXITED(status)) {
                    INFO("Container exited with code %d", WEXITSTATUS(status));
                } else if (WIFSIGNALED(status)) {
                    INFO("Container killed by signal %d", WTERMSIG(status));
                }
                container_pid = -1;
                // Don't exit, keep server running
            } else if (result < 0 && errno != ECHILD) {
                ERROR("waitpid failed: %s", strerror(errno));
            }
        }
        
        // Send test frames when EGL is not available and clients are connected
        if (send_test_frames && streaming_server->has_clients()) {
            test_frame_counter++;
            
            // Generate a simple animated test pattern
            for (uint32_t y = 0; y < display_height; y++) {
                for (uint32_t x = 0; x < display_width; x++) {
                    size_t offset = (y * display_width + x) * 4;
                    // Create a gradient with animation
                    test_frame[offset + 0] = static_cast<uint8_t>((x + test_frame_counter) % 256); // R
                    test_frame[offset + 1] = static_cast<uint8_t>((y + test_frame_counter) % 256); // G
                    test_frame[offset + 2] = static_cast<uint8_t>(((x + y) / 2 + test_frame_counter * 2) % 256); // B
                    test_frame[offset + 3] = 255; // A
                }
            }
            
            // Send the test frame
            streaming_server->send_frame(test_frame.data(), display_width, display_height,
                                         anbox::server::PIXEL_FORMAT_RGBA8888, 
                                         display_width * 4);
            
            // Log periodically
            if (test_frame_counter % 100 == 1) {
                INFO("Sent test frame %d to clients", test_frame_counter);
            }
            
            // Limit frame rate to ~30 FPS
            std::this_thread::sleep_for(std::chrono::milliseconds(33));
        } else {
            // Let the runtime process I/O events
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }

    // Cleanup
    INFO("Shutting down...");
    
    // Unregister layer composer
    unRegisterLayerComposer();
    streaming_composer_.reset();
    
    // Stop streaming server
    if (streaming_server) {
        streaming_server->stop();
    }
    
    // Stop runtime
    if (rt) {
        rt->stop();
    }
    
    // Kill container if still running
    if (container_pid > 0) {
        INFO("Stopping container (PID %d)...", container_pid);
        kill(container_pid, SIGTERM);
        int status;
        waitpid(container_pid, &status, 0);
    }

    INFO("Server stopped.");
    return 0;
}
