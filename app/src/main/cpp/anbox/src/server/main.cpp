/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include <iostream>
#include <string>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <getopt.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <limits.h>
#include <thread>

#include "anbox/logger.h"
#include "anbox/runtime.h"
#include "server/streaming_server.h"
#include "server/streaming_protocol.h"

static volatile bool running = true;
static pid_t container_pid = -1;

void signal_handler(int signum) {
    INFO("Received signal %d, shutting down...", signum);
    running = false;
    
    // Forward signal to child process if running
    if (container_pid > 0) {
        kill(container_pid, signum);
    }
}

void print_usage(const char* program) {
    std::cout << "Usage: " << program << " [options]\n"
              << "\n"
              << "Ananbox standalone server for Termux - runs Android containers with network streaming\n"
              << "\n"
              << "Options:\n"
              << "  -a, --address <ip>      Listen address (default: 0.0.0.0)\n"
              << "  -p, --port <port>       Listen port (default: " << anbox::server::DEFAULT_PORT << ")\n"
              << "  -w, --width <pixels>    Display width (default: 1280)\n"
              << "  -h, --height <pixels>   Display height (default: 720)\n"
              << "  -d, --dpi <dpi>         Display DPI (default: 160)\n"
              << "  -b, --base <path>       Base path (parent of rootfs, default: current directory)\n"
              << "  -P, --proot <path>      Path to proot/libproot.so (default: ./libproot.so)\n"
              << "  -s, --script <path>     Path to startup script (default: <base>/rootfs/run.sh)\n"
              << "  -t, --tmpdir <path>     Temporary directory for proot (default: <base>/tmp)\n"
              << "  -v, --verbose           Enable verbose logging\n"
              << "  --help                  Show this help message\n"
              << "\n"
              << "The base path should contain:\n"
              << "  - rootfs/         Android rootfs directory\n"
              << "  - rootfs/run.sh   Container startup script\n"
              << "\n"
              << "Example (in Termux):\n"
              << "  cd /data/data/com.termux/ananbox\n"
              << "  ./ananbox-server -b . -P ./libproot.so\n"
              << std::endl;
}

// Normalize a path - removes trailing slashes and handles relative paths
std::string normalize_path(const std::string& path) {
    std::string result = path;
    
    // Remove trailing slashes
    while (result.length() > 1 && result.back() == '/') {
        result.pop_back();
    }
    
    return result;
}

// Get the parent directory of a path
std::string get_parent_dir(const std::string& path) {
    size_t pos = path.rfind('/');
    if (pos == std::string::npos || pos == 0) {
        return ".";
    }
    return path.substr(0, pos);
}

// Create directory if it doesn't exist
bool ensure_directory(const std::string& path) {
    struct stat st;
    if (stat(path.c_str(), &st) == 0) {
        return S_ISDIR(st.st_mode);
    }
    return mkdir(path.c_str(), 0755) == 0;
}

int main(int argc, char* argv[]) {
    // Get current working directory as default base
    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd)) == nullptr) {
        ERROR("Failed to get current directory");
        return 1;
    }
    
    std::string listen_address = "0.0.0.0";
    uint16_t listen_port = anbox::server::DEFAULT_PORT;
    int display_width = 1280;
    int display_height = 720;
    int display_dpi = 160;
    std::string base_path = cwd;  // Default to current directory
    std::string proot_path = "./libproot.so";  // Default to local libproot.so
    std::string startup_script;  // Will default to <base>/rootfs/run.sh if not specified
    std::string tmp_dir;  // Will default to <base>/tmp if not specified
    bool verbose = false;

    static struct option long_options[] = {
        {"address", required_argument, 0, 'a'},
        {"port",    required_argument, 0, 'p'},
        {"width",   required_argument, 0, 'w'},
        {"height",  required_argument, 0, 'h'},
        {"dpi",     required_argument, 0, 'd'},
        {"base",    required_argument, 0, 'b'},
        {"proot",   required_argument, 0, 'P'},
        {"script",  required_argument, 0, 's'},
        {"tmpdir",  required_argument, 0, 't'},
        {"verbose", no_argument,       0, 'v'},
        {"help",    no_argument,       0, 0},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;
    while ((opt = getopt_long(argc, argv, "a:p:w:h:d:b:P:s:t:v", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'a':
                listen_address = optarg;
                break;
            case 'p':
                listen_port = static_cast<uint16_t>(std::stoi(optarg));
                break;
            case 'w':
                display_width = std::stoi(optarg);
                break;
            case 'h':
                display_height = std::stoi(optarg);
                break;
            case 'd':
                display_dpi = std::stoi(optarg);
                break;
            case 'b':
                base_path = normalize_path(optarg);
                break;
            case 'P':
                proot_path = optarg;
                break;
            case 's':
                startup_script = optarg;
                break;
            case 't':
                tmp_dir = optarg;
                break;
            case 'v':
                verbose = true;
                break;
            case 0:
                if (std::string(long_options[option_index].name) == "help") {
                    print_usage(argv[0]);
                    return 0;
                }
                break;
            default:
                print_usage(argv[0]);
                return 1;
        }
    }

    // Setup signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    signal(SIGCHLD, SIG_IGN);  // Ignore child exit to avoid zombies

    // Validate paths to prevent path traversal attacks
    auto validate_path = [](const std::string& path, const std::string& name) -> bool {
        // Check for null bytes
        if (path.find('\0') != std::string::npos) {
            ERROR("Invalid %s path: contains null byte", name.c_str());
            return false;
        }
        // Path should not be empty
        if (path.empty()) {
            ERROR("Invalid %s path: empty", name.c_str());
            return false;
        }
        return true;
    };
    
    if (!validate_path(base_path, "base") || !validate_path(proot_path, "proot")) {
        return 1;
    }

    // Normalize base path
    base_path = normalize_path(base_path);

    // Check if base directory exists
    struct stat st;
    if (stat(base_path.c_str(), &st) != 0 || !S_ISDIR(st.st_mode)) {
        ERROR("Base directory does not exist: %s", base_path.c_str());
        return 1;
    }

    // Construct rootfs path from base
    std::string rootfs_path = base_path + "/rootfs";
    
    // Check if rootfs directory exists
    if (stat(rootfs_path.c_str(), &st) != 0 || !S_ISDIR(st.st_mode)) {
        ERROR("Rootfs directory does not exist: %s", rootfs_path.c_str());
        ERROR("Expected rootfs at: %s/rootfs", base_path.c_str());
        return 1;
    }

    // Set default startup script if not specified
    if (startup_script.empty()) {
        startup_script = rootfs_path + "/run.sh";
    }

    // Set default tmp directory if not specified
    if (tmp_dir.empty()) {
        tmp_dir = base_path + "/tmp";
    }
    
    // Create tmp directory if it doesn't exist
    if (!ensure_directory(tmp_dir)) {
        ERROR("Failed to create temporary directory: %s", tmp_dir.c_str());
        return 1;
    }
    
    // Also create tmp inside rootfs for proot
    std::string rootfs_tmp = rootfs_path + "/tmp";
    ensure_directory(rootfs_tmp);

    INFO("Ananbox Server starting...");
    INFO("  Listen: %s:%d", listen_address.c_str(), listen_port);
    INFO("  Display: %dx%d @ %d DPI", display_width, display_height, display_dpi);
    INFO("  Base path: %s", base_path.c_str());
    INFO("  Rootfs: %s", rootfs_path.c_str());
    INFO("  Proot: %s", proot_path.c_str());
    INFO("  Temp dir: %s", tmp_dir.c_str());
    INFO("  Startup script: %s", startup_script.c_str());

    // Note: In Termux standalone mode, we skip EGL/renderer initialization
    // as we don't have a display. The server will just forward streaming data.
    INFO("Running in headless mode (no GPU rendering)");

    // Start the container if startup script is available
    if (access(startup_script.c_str(), F_OK) == 0) {
        INFO("Starting container using script: %s", startup_script.c_str());
        container_pid = fork();
        if (container_pid < 0) {
            ERROR("fork() failed: %s", strerror(errno));
            return 1;
        } else if (container_pid == 0) {
            // Child process
            sigset_t signals_to_unblock;
            sigfillset(&signals_to_unblock);
            sigprocmask(SIG_UNBLOCK, &signals_to_unblock, 0);
            
            // Change to base directory (same as app behavior)
            if (chdir(base_path.c_str()) != 0) {
                fprintf(stderr, "Failed to change to base directory: %s\n", strerror(errno));
                exit(1);
            }
            
            // Set PROOT_TMP_DIR environment variable
            setenv("PROOT_TMP_DIR", tmp_dir.c_str(), 1);
            
            // Execute the script the same way as the app does:
            // sh $base_path/rootfs/run.sh $base_path $proot_path
            // The script expects: $1 = base_path (parent of rootfs), $2 = proot_path
            const char* args[] = {
                "sh",
                startup_script.c_str(),
                base_path.c_str(),
                proot_path.c_str(),
                nullptr
            };
            
            execvp("sh", const_cast<char* const*>(args));
            
            fprintf(stderr, "Failed to start container: %s\n", strerror(errno));
            exit(1);
        } else {
            // Parent process
            INFO("Container process started with PID %d", container_pid);
        }
    } else {
        INFO("Startup script not found at %s", startup_script.c_str());
        INFO("Running server only (no container). Use -s to specify a startup script.");
    }

    // Initialize and start the streaming server
    std::shared_ptr<anbox::Runtime> runtime;
    std::shared_ptr<anbox::server::StreamingServer> streaming_server;
    
    try {
        // Create runtime for async I/O
        runtime = anbox::Runtime::create();
        
        // Start the runtime (this spawns worker threads for async I/O)
        runtime->start();
        
        // Create streaming server
        streaming_server = std::make_shared<anbox::server::StreamingServer>(
            runtime, listen_address, listen_port);
        
        // Set display configuration
        streaming_server->set_display_config(display_width, display_height, display_dpi);
        
        // Start the streaming server
        streaming_server->start();
        
        INFO("Streaming server listening on %s:%d", listen_address.c_str(), listen_port);
    } catch (const std::exception& e) {
        ERROR("Failed to start streaming server: %s", e.what());
        // Kill container if running
        if (container_pid > 0) {
            kill(container_pid, SIGTERM);
        }
        if (runtime) {
            runtime->stop();
        }
        return 1;
    }

    INFO("Server is running. Press Ctrl+C to stop.");

    // Main loop - wait for shutdown or child exit
    while (running) {
        if (container_pid > 0) {
            // Check if child process is still running
            int status;
            pid_t result = waitpid(container_pid, &status, WNOHANG);
            if (result == container_pid) {
                if (WIFEXITED(status)) {
                    INFO("Container exited with code %d", WEXITSTATUS(status));
                } else if (WIFSIGNALED(status)) {
                    INFO("Container killed by signal %d", WTERMSIG(status));
                }
                container_pid = -1;
                // Don't exit, keep server running
            } else if (result < 0 && errno != ECHILD) {
                ERROR("waitpid failed: %s", strerror(errno));
            }
        }
        
        // Let the runtime process I/O events
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    // Cleanup
    INFO("Shutting down...");
    
    // Stop streaming server
    if (streaming_server) {
        streaming_server->stop();
    }
    
    // Stop runtime
    if (runtime) {
        runtime->stop();
    }
    
    // Kill container if still running
    if (container_pid > 0) {
        INFO("Stopping container (PID %d)...", container_pid);
        kill(container_pid, SIGTERM);
        int status;
        waitpid(container_pid, &status, 0);
    }

    INFO("Server stopped.");
    return 0;
}
