/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include "server/streaming_server.h"
#include "anbox/network/tcp_socket_messenger.h"
#include "anbox/network/delegate_connection_creator.h"
#include "anbox/network/delegate_message_processor.h"
#include "anbox/logger.h"

#include <cstring>
#include <chrono>

namespace anbox::server {

StreamingServer::StreamingServer(const std::shared_ptr<Runtime>& runtime,
                                 const std::string& address,
                                 uint16_t port)
    : runtime_(runtime),
      connections_(std::make_shared<network::Connections<network::SocketConnection>>()) {
    
    auto delegate_connector = std::make_shared<
        network::DelegateConnectionCreator<boost::asio::ip::tcp>>(
        [this](std::shared_ptr<boost::asio::ip::tcp::socket> const& socket) {
            on_new_connection(socket);
        });

    boost::asio::ip::address_v4 addr = boost::asio::ip::address_v4::from_string(address);
    connector_ = std::make_shared<network::TcpSocketConnector>(
        addr, port, runtime, delegate_connector);
    
    INFO("Streaming server initialized on %s:%d", address.c_str(), port);
}

StreamingServer::~StreamingServer() {
    stop();
}

void StreamingServer::start() {
    INFO("Streaming server started");
}

void StreamingServer::stop() {
    INFO("Streaming server stopped");
    connections_->clear();
}

void StreamingServer::on_new_connection(
    std::shared_ptr<boost::asio::ip::tcp::socket> const& socket) {
    
    INFO("New client connection");
    
    auto messenger = std::make_shared<network::TcpSocketMessenger>(socket);
    
    int id = next_id_++;
    
    auto processor = std::make_shared<network::DelegateMessageProcessor>(
        [this, id](const std::vector<uint8_t>& data) -> bool {
            handle_client_message(id, data);
            return true;
        });
    
    auto connection = std::make_shared<network::SocketConnection>(
        messenger, messenger, id, connections_, processor);
    connection->set_name("streaming-client");
    connections_->add(connection);
    
    // Send handshake response with current display config
    HandshakeResponse response;
    response.server_version = PROTOCOL_VERSION;
    response.result = 0;
    response.display_width = display_width_;
    response.display_height = display_height_;
    response.display_dpi = display_dpi_;
    
    MessageHeader header;
    header.magic = PROTOCOL_MAGIC;
    header.version = PROTOCOL_VERSION;
    header.type = MessageType::HANDSHAKE_RESPONSE;
    header.payload_size = sizeof(HandshakeResponse);
    header.sequence = sequence_++;
    
    std::vector<char> msg(sizeof(MessageHeader) + sizeof(HandshakeResponse));
    std::memcpy(msg.data(), &header, sizeof(MessageHeader));
    std::memcpy(msg.data() + sizeof(MessageHeader), &response, sizeof(HandshakeResponse));
    
    connection->send(msg.data(), msg.size());
    connection->read_next_message();
    
    INFO("Client %d connected, display: %dx%d@%ddpi", id, display_width_, display_height_, display_dpi_);
}

void StreamingServer::handle_client_message(int id, const std::vector<uint8_t>& data) {
    if (data.size() < sizeof(MessageHeader)) {
        WARNING("Invalid message from client %d: too small", id);
        return;
    }
    
    const MessageHeader* header = reinterpret_cast<const MessageHeader*>(data.data());
    
    if (header->magic != PROTOCOL_MAGIC) {
        WARNING("Invalid magic from client %d", id);
        return;
    }
    
    if (data.size() < sizeof(MessageHeader) + header->payload_size) {
        WARNING("Incomplete message from client %d", id);
        return;
    }
    
    const uint8_t* payload = data.data() + sizeof(MessageHeader);
    
    switch (header->type) {
        case MessageType::HANDSHAKE_REQUEST: {
            if (header->payload_size >= sizeof(HandshakeRequest)) {
                const HandshakeRequest* req = reinterpret_cast<const HandshakeRequest*>(payload);
                INFO("Client %d handshake: version=%d, display=%dx%d@%ddpi",
                     id, req->client_version, req->display_width, req->display_height, req->display_dpi);
            }
            break;
        }
        
        case MessageType::TOUCH_EVENT: {
            if (header->payload_size >= sizeof(TouchEvent) && input_callback_) {
                const TouchEvent* event = reinterpret_cast<const TouchEvent*>(payload);
                input_callback_(*event);
            }
            break;
        }
        
        case MessageType::KEY_EVENT: {
            if (header->payload_size >= sizeof(KeyEvent) && key_callback_) {
                const KeyEvent* event = reinterpret_cast<const KeyEvent*>(payload);
                key_callback_(*event);
            }
            break;
        }
        
        case MessageType::PING: {
            // Respond with PONG
            MessageHeader pong;
            pong.magic = PROTOCOL_MAGIC;
            pong.version = PROTOCOL_VERSION;
            pong.type = MessageType::PONG;
            pong.payload_size = 0;
            pong.sequence = sequence_++;
            
            for (unsigned n = 0; n < connections_->size(); n++) {
                auto conn = connections_->at(n);
                if (conn && conn->id() == id) {
                    conn->send(reinterpret_cast<const char*>(&pong), sizeof(pong));
                    break;
                }
            }
            break;
        }
        
        case MessageType::DISCONNECT: {
            INFO("Client %d disconnecting", id);
            // Connection will be removed when it closes
            break;
        }
        
        default:
            DEBUG("Unknown message type from client %d: %d", id, static_cast<int>(header->type));
            break;
    }
}

void StreamingServer::broadcast_message(MessageType type, const void* data, uint32_t size) {
    if (connections_->size() == 0) {
        return;
    }
    
    MessageHeader header;
    header.magic = PROTOCOL_MAGIC;
    header.version = PROTOCOL_VERSION;
    header.type = type;
    header.payload_size = size;
    header.sequence = sequence_++;
    
    std::vector<char> msg(sizeof(MessageHeader) + size);
    std::memcpy(msg.data(), &header, sizeof(MessageHeader));
    if (data && size > 0) {
        std::memcpy(msg.data() + sizeof(MessageHeader), data, size);
    }
    
    for (unsigned n = 0; n < connections_->size(); n++) {
        auto conn = connections_->at(n);
        if (conn) {
            conn->send(msg.data(), msg.size());
        }
    }
}

void StreamingServer::send_frame(const void* data, uint32_t width, uint32_t height,
                                 uint32_t format, uint32_t stride) {
    if (connections_->size() == 0) {
        return;
    }
    
    auto now = std::chrono::steady_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::microseconds>(
        now.time_since_epoch()).count();
    
    FrameHeader frame_header;
    frame_header.width = width;
    frame_header.height = height;
    frame_header.format = format;
    frame_header.stride = stride;
    frame_header.timestamp = timestamp;
    frame_header.flags = FRAME_FLAG_KEYFRAME;
    
    uint32_t pixel_size = stride * height;
    uint32_t total_payload = sizeof(FrameHeader) + pixel_size;
    
    MessageHeader header;
    header.magic = PROTOCOL_MAGIC;
    header.version = PROTOCOL_VERSION;
    header.type = MessageType::FRAME_DATA;
    header.payload_size = total_payload;
    header.sequence = sequence_++;
    
    std::vector<char> msg(sizeof(MessageHeader) + total_payload);
    std::memcpy(msg.data(), &header, sizeof(MessageHeader));
    std::memcpy(msg.data() + sizeof(MessageHeader), &frame_header, sizeof(FrameHeader));
    std::memcpy(msg.data() + sizeof(MessageHeader) + sizeof(FrameHeader), data, pixel_size);
    
    for (unsigned n = 0; n < connections_->size(); n++) {
        auto conn = connections_->at(n);
        if (conn) {
            conn->send(msg.data(), msg.size());
        }
    }
}

void StreamingServer::send_audio(const void* data, uint32_t size) {
    if (connections_->size() == 0) {
        return;
    }
    
    auto now = std::chrono::steady_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::microseconds>(
        now.time_since_epoch()).count();
    
    AudioHeader audio_header;
    audio_header.size = size;
    audio_header.timestamp = timestamp;
    
    uint32_t total_payload = sizeof(AudioHeader) + size;
    
    MessageHeader header;
    header.magic = PROTOCOL_MAGIC;
    header.version = PROTOCOL_VERSION;
    header.type = MessageType::AUDIO_DATA;
    header.payload_size = total_payload;
    header.sequence = sequence_++;
    
    std::vector<char> msg(sizeof(MessageHeader) + total_payload);
    std::memcpy(msg.data(), &header, sizeof(MessageHeader));
    std::memcpy(msg.data() + sizeof(MessageHeader), &audio_header, sizeof(AudioHeader));
    std::memcpy(msg.data() + sizeof(MessageHeader) + sizeof(AudioHeader), data, size);
    
    for (unsigned n = 0; n < connections_->size(); n++) {
        auto conn = connections_->at(n);
        if (conn) {
            conn->send(msg.data(), msg.size());
        }
    }
}

void StreamingServer::set_display_config(uint32_t width, uint32_t height, uint32_t dpi) {
    std::lock_guard<std::mutex> lock(mutex_);
    display_width_ = width;
    display_height_ = height;
    display_dpi_ = dpi;
    
    DisplayConfig config;
    config.width = width;
    config.height = height;
    config.dpi = dpi;
    config.format = PIXEL_FORMAT_RGBA8888;
    
    broadcast_message(MessageType::DISPLAY_CONFIG, &config, sizeof(config));
}

void StreamingServer::set_audio_config(uint32_t sample_rate, uint8_t channels, uint8_t bits_per_sample) {
    std::lock_guard<std::mutex> lock(mutex_);
    audio_sample_rate_ = sample_rate;
    audio_channels_ = channels;
    audio_bits_ = bits_per_sample;
    
    AudioConfig config;
    config.sample_rate = sample_rate;
    config.channels = channels;
    config.bits_per_sample = bits_per_sample;
    config.reserved = 0;
    
    broadcast_message(MessageType::AUDIO_CONFIG, &config, sizeof(config));
}

void StreamingServer::set_input_callback(InputEventCallback callback) {
    input_callback_ = callback;
}

void StreamingServer::set_key_callback(KeyEventCallback callback) {
    key_callback_ = callback;
}

bool StreamingServer::has_clients() const {
    return connections_->size() > 0;
}

} // namespace anbox::server
