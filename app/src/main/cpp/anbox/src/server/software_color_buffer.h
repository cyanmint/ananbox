/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * Software-only color buffer storage for headless server mode.
 * Stores raw pixel data in memory without requiring OpenGL/EGL.
 */

#ifndef ANBOX_SERVER_SOFTWARE_COLOR_BUFFER_H_
#define ANBOX_SERVER_SOFTWARE_COLOR_BUFFER_H_

#include <cstdint>
#include <vector>
#include <map>
#include <mutex>
#include <memory>

namespace anbox::server {

/**
 * Stores raw pixel data for a single color buffer
 */
class SoftwareColorBuffer {
public:
    SoftwareColorBuffer(int width, int height);
    
    void update(int x, int y, int width, int height, 
                uint32_t format, uint32_t type, const void* pixels);
    
    void read(int x, int y, int width, int height,
              uint32_t format, uint32_t type, void* pixels) const;
    
    int width() const { return width_; }
    int height() const { return height_; }
    const std::vector<uint8_t>& data() const { return pixels_; }
    
private:
    int width_;
    int height_;
    std::vector<uint8_t> pixels_;  // RGBA format
};

/**
 * Global store for all software color buffers
 */
class SoftwareColorBufferStore {
public:
    static SoftwareColorBufferStore& instance();
    
    // Create a new color buffer and return its handle
    uint32_t create(int width, int height);
    
    // Destroy a color buffer
    void destroy(uint32_t handle);
    
    // Update color buffer contents
    bool update(uint32_t handle, int x, int y, int width, int height,
                uint32_t format, uint32_t type, const void* pixels);
    
    // Read color buffer contents
    bool read(uint32_t handle, int x, int y, int width, int height,
              uint32_t format, uint32_t type, void* pixels) const;
    
    // Get color buffer info
    bool getInfo(uint32_t handle, int* width, int* height) const;
    
    // Get direct access to buffer data
    const SoftwareColorBuffer* get(uint32_t handle) const;

private:
    SoftwareColorBufferStore() = default;
    
    mutable std::mutex mutex_;
    std::map<uint32_t, std::unique_ptr<SoftwareColorBuffer>> buffers_;
    uint32_t next_handle_ = 1;
};

} // namespace anbox::server

#endif // ANBOX_SERVER_SOFTWARE_COLOR_BUFFER_H_
