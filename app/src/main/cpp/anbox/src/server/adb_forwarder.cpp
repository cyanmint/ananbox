/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranties of
 * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
 * PURPOSE.
 */

#include "server/adb_forwarder.h"
#include "anbox/network/tcp_socket_messenger.h"
#include "anbox/network/delegate_connection_creator.h"
#include "anbox/logger.h"

#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <cstring>

namespace anbox::server {

// Default ADB port (standard Android wireless ADB port)
static constexpr uint16_t DEFAULT_ADB_PORT = 5555;

// Buffer size for data forwarding
static constexpr size_t FORWARD_BUFFER_SIZE = 32768;

AdbForwarder::AdbForwarder(const std::shared_ptr<Runtime>& runtime,
                           const std::string& listen_address,
                           uint16_t listen_port,
                           const std::string& adb_socket_path,
                           const std::string& rootfs_path)
    : runtime_(runtime),
      listen_address_(listen_address),
      listen_port_(listen_port),
      adb_socket_path_(adb_socket_path),
      rootfs_path_(rootfs_path) {
    
    INFO("ADB forwarder initializing: %s:%d -> %s (in rootfs: %s)",
         listen_address.c_str(), listen_port,
         adb_socket_path.c_str(), rootfs_path.c_str());
}

AdbForwarder::~AdbForwarder() {
    stop();
}

void AdbForwarder::start() {
    if (running_) return;
    
    INFO("Starting ADB forwarder on %s:%d...", listen_address_.c_str(), listen_port_);
    running_ = true;
    
    auto delegate_connector = std::make_shared<
        network::DelegateConnectionCreator<boost::asio::ip::tcp>>(
        [this](std::shared_ptr<boost::asio::ip::tcp::socket> const& socket) {
            on_new_connection(socket);
        });

    try {
        boost::asio::ip::address_v4 addr = boost::asio::ip::address_v4::from_string(listen_address_);
        connector_ = std::make_shared<network::TcpSocketConnector>(
            addr, listen_port_, runtime_, delegate_connector);
        INFO("ADB forwarder now listening on %s:%d", listen_address_.c_str(), listen_port_);
        INFO("To connect via ADB: adb connect %s:%d", listen_address_.c_str(), listen_port_);
    } catch (const boost::system::system_error& e) {
        ERROR("Failed to start ADB forwarder on %s:%d: %s", 
              listen_address_.c_str(), listen_port_, e.what());
        running_ = false;
        throw;
    } catch (const std::exception& e) {
        ERROR("Failed to start ADB forwarder: %s", e.what());
        running_ = false;
        throw;
    }
}

void AdbForwarder::stop() {
    if (!running_) return;
    
    INFO("Stopping ADB forwarder...");
    running_ = false;
    
    // Wait for all forward threads to finish
    std::lock_guard<std::mutex> lock(mutex_);
    for (auto& thread : forward_threads_) {
        if (thread.joinable()) {
            thread.join();
        }
    }
    forward_threads_.clear();
    
    connector_.reset();
    INFO("ADB forwarder stopped");
}

int AdbForwarder::connect_to_adb_socket() {
    // Construct the full path to the ADB socket
    std::string full_path = rootfs_path_ + adb_socket_path_;
    
    DEBUG("Connecting to ADB socket: %s", full_path.c_str());
    
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock < 0) {
        ERROR("Failed to create Unix socket: %s", strerror(errno));
        return -1;
    }
    
    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    
    // Check if path is too long
    if (full_path.length() >= sizeof(addr.sun_path)) {
        ERROR("ADB socket path too long: %s", full_path.c_str());
        close(sock);
        return -1;
    }
    
    strncpy(addr.sun_path, full_path.c_str(), sizeof(addr.sun_path) - 1);
    
    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        DEBUG("Failed to connect to ADB socket %s: %s", full_path.c_str(), strerror(errno));
        close(sock);
        return -1;
    }
    
    DEBUG("Connected to ADB socket: %s", full_path.c_str());
    return sock;
}

void AdbForwarder::on_new_connection(
    std::shared_ptr<boost::asio::ip::tcp::socket> const& socket) {
    
    // Get remote address for logging
    std::string remote_addr = "unknown";
    try {
        auto endpoint = socket->remote_endpoint();
        remote_addr = endpoint.address().to_string() + ":" + std::to_string(endpoint.port());
    } catch (...) {}
    
    int connection_id = next_id_++;
    INFO("ADB forwarder: new connection #%d from %s", connection_id, remote_addr.c_str());
    
    // Get the native socket descriptor
    int client_fd = socket->native_handle();
    
    // Try to connect to the ADB socket in the container
    int adb_fd = connect_to_adb_socket();
    if (adb_fd < 0) {
        WARNING("ADB forwarder: could not connect to container ADB socket for client #%d", 
                connection_id);
        WARNING("Make sure the container is running and ADB is enabled");
        // Close the client socket
        try {
            socket->close();
        } catch (...) {}
        return;
    }
    
    // Detach the socket from boost::asio so we can manage it ourselves
    boost::system::error_code ec;
    socket->release(ec);
    if (ec) {
        ERROR("Failed to release socket: %s", ec.message().c_str());
        close(adb_fd);
        return;
    }
    
    client_count_++;
    INFO("ADB forwarder: connection #%d established (total clients: %d)", 
         connection_id, client_count_.load());
    
    // Start forwarding in a separate thread
    std::lock_guard<std::mutex> lock(mutex_);
    forward_threads_.emplace_back(&AdbForwarder::forward_data, this, 
                                  client_fd, adb_fd, connection_id);
}

void AdbForwarder::forward_data(int client_fd, int adb_fd, int connection_id) {
    // Set both sockets to non-blocking
    fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);
    fcntl(adb_fd, F_SETFL, fcntl(adb_fd, F_GETFL) | O_NONBLOCK);
    
    std::vector<uint8_t> buffer(FORWARD_BUFFER_SIZE);
    
    struct pollfd fds[2];
    fds[0].fd = client_fd;
    fds[0].events = POLLIN;
    fds[1].fd = adb_fd;
    fds[1].events = POLLIN;
    
    while (running_) {
        int ret = poll(fds, 2, 1000);  // 1 second timeout
        
        if (ret < 0) {
            if (errno == EINTR) continue;
            ERROR("ADB forwarder #%d: poll error: %s", connection_id, strerror(errno));
            break;
        }
        
        if (ret == 0) {
            // Timeout, check if still running
            continue;
        }
        
        // Check for errors
        if ((fds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) ||
            (fds[1].revents & (POLLERR | POLLHUP | POLLNVAL))) {
            DEBUG("ADB forwarder #%d: connection closed", connection_id);
            break;
        }
        
        // Forward data from client to ADB
        if (fds[0].revents & POLLIN) {
            ssize_t n = read(client_fd, buffer.data(), buffer.size());
            if (n <= 0) {
                if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
                    // No data available, continue
                } else {
                    DEBUG("ADB forwarder #%d: client disconnected", connection_id);
                    break;
                }
            } else {
                // Write to ADB socket
                ssize_t written = 0;
                while (written < n) {
                    ssize_t w = write(adb_fd, buffer.data() + written, n - written);
                    if (w < 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            // Would block, wait a bit
                            usleep(1000);
                            continue;
                        }
                        ERROR("ADB forwarder #%d: write to ADB failed: %s", 
                              connection_id, strerror(errno));
                        goto cleanup;
                    }
                    written += w;
                }
            }
        }
        
        // Forward data from ADB to client
        if (fds[1].revents & POLLIN) {
            ssize_t n = read(adb_fd, buffer.data(), buffer.size());
            if (n <= 0) {
                if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
                    // No data available, continue
                } else {
                    DEBUG("ADB forwarder #%d: ADB socket disconnected", connection_id);
                    break;
                }
            } else {
                // Write to client socket
                ssize_t written = 0;
                while (written < n) {
                    ssize_t w = write(client_fd, buffer.data() + written, n - written);
                    if (w < 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            // Would block, wait a bit
                            usleep(1000);
                            continue;
                        }
                        ERROR("ADB forwarder #%d: write to client failed: %s", 
                              connection_id, strerror(errno));
                        goto cleanup;
                    }
                    written += w;
                }
            }
        }
    }
    
cleanup:
    close(client_fd);
    close(adb_fd);
    client_count_--;
    INFO("ADB forwarder: connection #%d closed (remaining clients: %d)", 
         connection_id, client_count_.load());
}

bool AdbForwarder::has_clients() const {
    return client_count_ > 0;
}

} // namespace anbox::server
