/*
 * This file was generated by AI and is not subject to copyright protection.
 * AI-generated content is not applicable for copyright.
 */
package com.github.ananbox

import android.os.Bundle
import android.util.Log
import android.view.MenuItem
import android.widget.ScrollView
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import java.io.BufferedReader
import java.io.File
import java.io.IOException
import java.io.InputStreamReader
import java.util.Date

class LogViewActivity : AppCompatActivity() {

    private companion object {
        private const val TAG = "LogViewActivity"
        // Maximum log file size to read (1MB)
        private const val MAX_LOG_SIZE = 1024 * 1024L
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_log_view)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setTitle(R.string.settings_logs_title)

        val logTextView = findViewById<TextView>(R.id.log_text_view)
        val scrollView = findViewById<ScrollView>(R.id.log_scroll_view)

        val logContent = StringBuilder()
        val verboseMode = SettingsActivity.isVerboseModeEnabled(this)

        // Add device info header in verbose mode
        if (verboseMode) {
            logContent.append("=== Device Information ===\n")
            logContent.append("Timestamp: ${Date()}\n")
            logContent.append("Device: ${android.os.Build.MANUFACTURER} ${android.os.Build.MODEL}\n")
            logContent.append("Android: ${android.os.Build.VERSION.RELEASE} (SDK ${android.os.Build.VERSION.SDK_INT})\n")
            logContent.append("Verbose Mode: Enabled\n\n")
        }

        // Read proot.log from internal storage
        val prootLogFile = File(filesDir, "proot.log")
        try {
            if (prootLogFile.exists()) {
                logContent.append("=== proot.log ===\n")
                logContent.append(readLogFile(prootLogFile))
                logContent.append("\n\n")
            }
        } catch (e: IOException) {
            Log.e(TAG, "Failed to read proot.log", e)
            logContent.append("Error reading proot.log: ${e.message}\n\n")
        }

        // Read system.log from rootfs/data
        val systemLogFile = File(filesDir, "rootfs/data/system.log")
        try {
            if (systemLogFile.exists()) {
                logContent.append("=== system.log ===\n")
                logContent.append(readLogFile(systemLogFile))
                logContent.append("\n\n")
            }
        } catch (e: IOException) {
            Log.e(TAG, "Failed to read system.log", e)
            logContent.append("Error reading system.log: ${e.message}\n\n")
        }

        // Read container.log if available
        val containerLogFile = File(filesDir, "container.log")
        try {
            if (containerLogFile.exists()) {
                logContent.append("=== container.log ===\n")
                logContent.append(readLogFile(containerLogFile))
                logContent.append("\n\n")
            }
        } catch (e: IOException) {
            Log.e(TAG, "Failed to read container.log", e)
            logContent.append("Error reading container.log: ${e.message}\n\n")
        }

        // Read server.log if available (embedded server output)
        val serverLogFile = File(filesDir, "server.log")
        try {
            if (serverLogFile.exists()) {
                logContent.append("=== server.log ===\n")
                logContent.append(readLogFile(serverLogFile))
                logContent.append("\n\n")
            }
        } catch (e: IOException) {
            Log.e(TAG, "Failed to read server.log", e)
            logContent.append("Error reading server.log: ${e.message}\n\n")
        }

        // In verbose mode, show additional diagnostic information
        if (verboseMode) {
            // Add process list
            logContent.append("=== Running Processes ===\n")
            logContent.append(collectProcessList())
            logContent.append("\n")
            
            // Add container processes
            logContent.append("=== Container Processes ===\n")
            logContent.append(collectContainerProcesses())
            logContent.append("\n")
            
            // Add logcat excerpt
            logContent.append("=== Recent Logcat (Ananbox) ===\n")
            logContent.append(collectLogcatExcerpt())
            logContent.append("\n")
        }

        if (logContent.isEmpty()) {
            logContent.append(getString(R.string.settings_logs_empty))
        }

        logTextView.text = logContent.toString()

        // Scroll to bottom to show most recent logs
        scrollView.post {
            scrollView.fullScroll(ScrollView.FOCUS_DOWN)
        }
    }

    @Throws(IOException::class)
    private fun readLogFile(file: File): String {
        return if (file.length() > MAX_LOG_SIZE) {
            // For large files, read only the last MAX_LOG_SIZE bytes using RandomAccessFile
            java.io.RandomAccessFile(file, "r").use { raf ->
                raf.seek(file.length() - MAX_LOG_SIZE)
                // Skip to next newline to avoid partial line
                raf.readLine()
                val remainingSize = file.length() - raf.filePointer
                // Safety check to prevent integer overflow
                if (remainingSize > MAX_LOG_SIZE || remainingSize < 0) {
                    return@use "[...truncated - file too large...]\n"
                }
                val remaining = ByteArray(remainingSize.toInt())
                raf.readFully(remaining)
                "[...truncated...]\n" + String(remaining, Charsets.UTF_8)
            }
        } else {
            file.readText()
        }
    }

    private fun collectProcessList(): String {
        return try {
            val process = Runtime.getRuntime().exec(arrayOf("ps", "-A"))
            val reader = BufferedReader(InputStreamReader(process.inputStream))
            val output = StringBuilder()
            reader.useLines { lines ->
                lines.take(50).forEach { line ->  // Limit to first 50 lines for display
                    output.append(line).append("\n")
                }
            }
            process.waitFor()
            if (output.isEmpty()) "No processes found\n" else output.toString()
        } catch (e: Exception) {
            "Failed to get process list: ${e.message}\n"
        }
    }

    private fun collectContainerProcesses(): String {
        val output = StringBuilder()
        try {
            val rootfsDir = File(filesDir, "rootfs")
            if (rootfsDir.exists()) {
                val procDir = File(rootfsDir, "proc")
                if (procDir.exists() && procDir.isDirectory) {
                    var count = 0
                    procDir.listFiles()?.filter { it.name.matches(Regex("\\d+")) }?.forEach { pidDir ->
                        if (count >= 30) return@forEach  // Limit for display
                        try {
                            val cmdlineFile = File(pidDir, "cmdline")
                            if (cmdlineFile.exists()) {
                                val cmdline = cmdlineFile.readText().replace('\u0000', ' ').trim()
                                if (cmdline.isNotEmpty()) {
                                    output.append("PID ${pidDir.name}: $cmdline\n")
                                    count++
                                }
                            }
                        } catch (e: Exception) {
                            // Ignore individual process read errors
                        }
                    }
                }
                if (output.isEmpty()) {
                    output.append("No container processes found (container may not be running)\n")
                }
            } else {
                output.append("Rootfs not installed\n")
            }
        } catch (e: Exception) {
            output.append("Failed to read container processes: ${e.message}\n")
        }
        return output.toString()
    }

    private fun collectLogcatExcerpt(): String {
        return try {
            val process = Runtime.getRuntime().exec(arrayOf("logcat", "-d", "-v", "time", "-s", "libAnbox:*", "Anbox:*", "MainActivity:*", "SettingsActivity:*", "proot:*"))
            val reader = BufferedReader(InputStreamReader(process.inputStream))
            val output = StringBuilder()
            val linesList = reader.readLines()
            linesList.takeLast(100).forEach { line: String ->
                output.append(line).append("\n")
            }
            process.waitFor()
            if (output.isEmpty()) "No relevant logcat entries found\n" else output.toString()
        } catch (e: Exception) {
            "Failed to collect logcat: ${e.message}\n"
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            android.R.id.home -> {
                finish()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }
}
