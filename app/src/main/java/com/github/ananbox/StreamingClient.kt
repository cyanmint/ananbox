/*
 * This file was generated by AI and is not subject to copyright protection.
 * It is dedicated to the public domain.
 */
package com.github.ananbox

import android.graphics.Bitmap
import android.util.Log
import java.io.DataInputStream
import java.io.DataOutputStream
import java.io.IOException
import java.net.InetSocketAddress
import java.net.Socket
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.concurrent.LinkedBlockingQueue
import kotlin.concurrent.thread

/**
 * Client for connecting to a remote Ananbox streaming server.
 * Handles graphics, audio, and input streaming over TCP.
 */
class StreamingClient {
    companion object {
        private const val TAG = "StreamingClient"
        
        // Protocol constants matching the C++ server
        private const val PROTOCOL_VERSION = 1
        private const val PROTOCOL_MAGIC = 0x414E4258 // "ANBX"
        private const val DEFAULT_PORT = 5558
        
        // Message types
        private const val MSG_HANDSHAKE_REQUEST: Byte = 0x01
        private const val MSG_HANDSHAKE_RESPONSE: Byte = 0x02
        private const val MSG_FRAME_DATA: Byte = 0x10
        private const val MSG_DISPLAY_CONFIG: Byte = 0x11
        private const val MSG_AUDIO_DATA: Byte = 0x20
        private const val MSG_AUDIO_CONFIG: Byte = 0x21
        private const val MSG_TOUCH_EVENT: Byte = 0x30
        private const val MSG_KEY_EVENT: Byte = 0x31
        private const val MSG_MOUSE_EVENT: Byte = 0x32
        private const val MSG_PING: Byte = 0x40
        private const val MSG_PONG: Byte = 0x41
        private const val MSG_DISCONNECT: Byte = 0x42
        
        // Touch actions
        private const val TOUCH_ACTION_DOWN: Byte = 0
        private const val TOUCH_ACTION_UP: Byte = 1
        private const val TOUCH_ACTION_MOVE: Byte = 2
        
        // Pixel formats
        private const val PIXEL_FORMAT_RGBA8888 = 1
        
        // Maximum payload size to prevent memory exhaustion (100 MB)
        private const val MAX_PAYLOAD_SIZE = 100 * 1024 * 1024
        
        // Maximum reasonable frame dimensions
        private const val MAX_FRAME_DIMENSION = 8192
    }
    
    interface Listener {
        fun onConnected(width: Int, height: Int, dpi: Int)
        fun onDisconnected(reason: String?)
        fun onFrame(bitmap: Bitmap)
        fun onAudioData(data: ByteArray, sampleRate: Int, channels: Int, bitsPerSample: Int)
        fun onDisplayConfigChanged(width: Int, height: Int, dpi: Int)
        fun onError(error: String)
    }
    
    // Message to send (type, payload)
    private data class OutgoingMessage(val type: Byte, val payload: ByteArray)
    
    private var socket: Socket? = null
    private var inputStream: DataInputStream? = null
    private var outputStream: DataOutputStream? = null
    private var listener: Listener? = null
    private var running = false
    private var receiveThread: Thread? = null
    private var sendThread: Thread? = null
    private var sequence = 0
    
    // Queue for outgoing messages to avoid NetworkOnMainThreadException
    private val sendQueue = LinkedBlockingQueue<OutgoingMessage>()
    
    // Display configuration received from server
    private var displayWidth = 1280
    private var displayHeight = 720
    private var displayDpi = 160
    
    // Audio configuration
    private var audioSampleRate = 44100
    private var audioChannels = 2
    private var audioBitsPerSample = 16
    
    fun setListener(listener: Listener?) {
        this.listener = listener
    }
    
    fun connect(address: String, port: Int = DEFAULT_PORT, width: Int, height: Int, dpi: Int): Boolean {
        if (running) {
            disconnect()
        }
        
        return try {
            Log.i(TAG, "Connecting to $address:$port...")
            socket = Socket()
            socket?.connect(InetSocketAddress(address, port), 5000)
            socket?.tcpNoDelay = true
            
            inputStream = DataInputStream(socket?.getInputStream())
            outputStream = DataOutputStream(socket?.getOutputStream())
            
            running = true
            
            // Clear any pending messages from previous connection
            sendQueue.clear()
            
            // Start send thread first to handle handshake
            sendThread = thread(start = true, name = "StreamingClient-Send") {
                sendLoop()
            }
            
            // Send handshake request
            sendHandshake(width, height, dpi)
            
            // Start receive thread
            receiveThread = thread(start = true, name = "StreamingClient-Receive") {
                receiveLoop()
            }
            
            Log.i(TAG, "Connected successfully")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Connection failed: ${e.message}")
            listener?.onError("Connection failed: ${e.message}")
            cleanup()
            false
        }
    }
    
    fun disconnect() {
        Log.i(TAG, "Disconnecting...")
        running = false
        
        try {
            // Send disconnect message - use direct send since we're shutting down
            sendMessageDirect(MSG_DISCONNECT, ByteArray(0))
        } catch (e: Exception) {
            // Ignore errors during disconnect
        }
        
        cleanup()
    }
    
    private fun cleanup() {
        running = false
        
        // Clear the send queue
        sendQueue.clear()
        
        try {
            inputStream?.close()
        } catch (e: Exception) {}
        
        try {
            outputStream?.close()
        } catch (e: Exception) {}
        
        try {
            socket?.close()
        } catch (e: Exception) {}
        
        inputStream = null
        outputStream = null
        socket = null
        
        receiveThread?.interrupt()
        receiveThread = null
        
        sendThread?.interrupt()
        sendThread = null
    }
    
    private fun sendHandshake(width: Int, height: Int, dpi: Int) {
        val payload = ByteBuffer.allocate(16)
            .order(ByteOrder.LITTLE_ENDIAN)
            .putInt(PROTOCOL_VERSION)
            .putInt(width)
            .putInt(height)
            .putInt(dpi)
            .array()
        
        queueMessage(MSG_HANDSHAKE_REQUEST, payload)
    }
    
    fun sendTouchEvent(x: Int, y: Int, fingerId: Int, action: Int) {
        if (!running) return
        
        val touchAction = when (action) {
            0 -> TOUCH_ACTION_DOWN  // ACTION_DOWN
            1 -> TOUCH_ACTION_UP    // ACTION_UP
            2 -> TOUCH_ACTION_MOVE  // ACTION_MOVE
            else -> return
        }
        
        val payload = ByteBuffer.allocate(16)
            .order(ByteOrder.LITTLE_ENDIAN)
            .putInt(x)
            .putInt(y)
            .putInt(fingerId)
            .put(touchAction)
            .put(0) // reserved
            .put(0) // reserved
            .put(0) // reserved
            .array()
        
        queueMessage(MSG_TOUCH_EVENT, payload)
    }
    
    fun sendPing() {
        if (!running) return
        queueMessage(MSG_PING, ByteArray(0))
    }
    
    /**
     * Queue a message to be sent on the background send thread.
     * This is safe to call from the main UI thread.
     */
    private fun queueMessage(type: Byte, payload: ByteArray) {
        if (!running) return
        sendQueue.offer(OutgoingMessage(type, payload))
    }
    
    /**
     * Background thread that processes the send queue.
     */
    private fun sendLoop() {
        while (running) {
            try {
                val message = sendQueue.poll(100, java.util.concurrent.TimeUnit.MILLISECONDS)
                if (message != null) {
                    sendMessageDirect(message.type, message.payload)
                }
            } catch (e: InterruptedException) {
                break
            }
        }
    }
    
    /**
     * Actually send a message to the server. Must be called from background thread.
     */
    @Synchronized
    private fun sendMessageDirect(type: Byte, payload: ByteArray) {
        try {
            val output = outputStream ?: return
            
            // Write header
            val header = ByteBuffer.allocate(14)
                .order(ByteOrder.LITTLE_ENDIAN)
                .putInt(PROTOCOL_MAGIC)
                .put(PROTOCOL_VERSION.toByte())
                .put(type)
                .putInt(payload.size)
                .putInt(sequence++)
                .array()
            
            output.write(header)
            if (payload.isNotEmpty()) {
                output.write(payload)
            }
            output.flush()
        } catch (e: IOException) {
            Log.e(TAG, "Failed to send message: ${e.message}")
            handleDisconnect("Send error: ${e.message}")
        }
    }
    
    private fun receiveLoop() {
        val headerBuffer = ByteArray(14)
        
        while (running) {
            try {
                val input = inputStream ?: break
                
                // Read header
                input.readFully(headerBuffer)
                val header = ByteBuffer.wrap(headerBuffer).order(ByteOrder.LITTLE_ENDIAN)
                
                val magic = header.int
                if (magic != PROTOCOL_MAGIC) {
                    Log.w(TAG, "Invalid magic: 0x%08X, expected 0x%08X".format(magic, PROTOCOL_MAGIC))
                    continue
                }
                
                val version = header.get()
                val type = header.get()
                val payloadSize = header.int
                val seq = header.int
                
                // Validate payload size to prevent memory exhaustion
                if (payloadSize < 0 || payloadSize > MAX_PAYLOAD_SIZE) {
                    Log.w(TAG, "Invalid payload size: $payloadSize, max allowed: $MAX_PAYLOAD_SIZE")
                    handleDisconnect("Invalid payload size")
                    break
                }
                
                // Read payload
                val payload = if (payloadSize > 0) {
                    ByteArray(payloadSize).also { input.readFully(it) }
                } else {
                    ByteArray(0)
                }
                
                // Process message
                handleMessage(type, payload)
                
            } catch (e: IOException) {
                if (running) {
                    Log.e(TAG, "Receive error: ${e.message}")
                    handleDisconnect("Receive error: ${e.message}")
                }
                break
            } catch (e: Exception) {
                Log.e(TAG, "Error processing message: ${e.message}")
            }
        }
    }
    
    private fun handleMessage(type: Byte, payload: ByteArray) {
        when (type) {
            MSG_HANDSHAKE_RESPONSE -> handleHandshakeResponse(payload)
            MSG_FRAME_DATA -> handleFrameData(payload)
            MSG_DISPLAY_CONFIG -> handleDisplayConfig(payload)
            MSG_AUDIO_DATA -> handleAudioData(payload)
            MSG_AUDIO_CONFIG -> handleAudioConfig(payload)
            MSG_PONG -> Log.d(TAG, "Received PONG")
            MSG_DISCONNECT -> handleDisconnect("Server disconnected")
            else -> Log.d(TAG, "Unknown message type: $type")
        }
    }
    
    private fun handleHandshakeResponse(payload: ByteArray) {
        if (payload.size < 20) {
            Log.e(TAG, "Invalid handshake response size")
            return
        }
        
        val buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN)
        val serverVersion = buffer.int
        val result = buffer.int
        displayWidth = buffer.int
        displayHeight = buffer.int
        displayDpi = buffer.int
        
        Log.i(TAG, "Handshake response: version=$serverVersion, result=$result, display=${displayWidth}x${displayHeight}@${displayDpi}dpi")
        
        if (result == 0) {
            listener?.onConnected(displayWidth, displayHeight, displayDpi)
        } else {
            listener?.onError("Handshake failed with result: $result")
            disconnect()
        }
    }
    
    private fun handleFrameData(payload: ByteArray) {
        if (payload.size < 28) {
            Log.w(TAG, "Invalid frame data size")
            return
        }
        
        val buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN)
        val width = buffer.int
        val height = buffer.int
        val format = buffer.int
        val stride = buffer.int
        val timestamp = buffer.long
        val flags = buffer.int
        
        // Validate dimensions to prevent integer overflow and memory issues
        if (width <= 0 || height <= 0 || stride <= 0 ||
            width > MAX_FRAME_DIMENSION || height > MAX_FRAME_DIMENSION) {
            Log.w(TAG, "Invalid frame dimensions: ${width}x${height}, stride=$stride")
            return
        }
        
        // Use Long to check for overflow before creating the byte array
        val pixelDataSizeLong = stride.toLong() * height.toLong()
        if (pixelDataSizeLong > MAX_PAYLOAD_SIZE || pixelDataSizeLong > Int.MAX_VALUE) {
            Log.w(TAG, "Frame pixel data too large: $pixelDataSizeLong")
            return
        }
        
        val pixelDataSize = pixelDataSizeLong.toInt()
        if (payload.size < 28 + pixelDataSize) {
            Log.w(TAG, "Incomplete frame data")
            return
        }
        
        try {
            // Create bitmap from pixel data
            val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            val pixelData = ByteBuffer.wrap(payload, 28, pixelDataSize)
            bitmap.copyPixelsFromBuffer(pixelData)
            
            listener?.onFrame(bitmap)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to decode frame: ${e.message}")
        }
    }
    
    private fun handleDisplayConfig(payload: ByteArray) {
        if (payload.size < 16) {
            return
        }
        
        val buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN)
        displayWidth = buffer.int
        displayHeight = buffer.int
        displayDpi = buffer.int
        val format = buffer.int
        
        Log.i(TAG, "Display config updated: ${displayWidth}x${displayHeight}@${displayDpi}dpi")
        listener?.onDisplayConfigChanged(displayWidth, displayHeight, displayDpi)
    }
    
    private fun handleAudioData(payload: ByteArray) {
        if (payload.size < 12) {
            return
        }
        
        val buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN)
        val size = buffer.int
        val timestamp = buffer.long
        
        if (payload.size < 12 + size) {
            return
        }
        
        val audioData = payload.copyOfRange(12, 12 + size)
        listener?.onAudioData(audioData, audioSampleRate, audioChannels, audioBitsPerSample)
    }
    
    private fun handleAudioConfig(payload: ByteArray) {
        if (payload.size < 8) {
            return
        }
        
        val buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN)
        audioSampleRate = buffer.int
        audioChannels = buffer.get().toInt() and 0xFF
        audioBitsPerSample = buffer.get().toInt() and 0xFF
        
        Log.i(TAG, "Audio config: ${audioSampleRate}Hz, $audioChannels channels, $audioBitsPerSample bits")
    }
    
    private fun handleDisconnect(reason: String?) {
        running = false
        cleanup()
        listener?.onDisconnected(reason)
    }
    
    fun isConnected(): Boolean = running && socket?.isConnected == true
}
